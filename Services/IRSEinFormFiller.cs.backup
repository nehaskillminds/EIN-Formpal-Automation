using EinAutomation.Api.Models;
using EinAutomation.Api.Services.Interfaces;
using Microsoft.Extensions.Logging;
using OpenQA.Selenium;
using OpenQA.Selenium.Support.UI;
using OpenQA.Selenium.Chrome;
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Text.Json;
using System.Linq;
using HtmlAgilityPack;
using EinAutomation.Api.Infrastructure;
using System.Net;
using System.Reflection;
using OpenQA.Selenium.Interactions; // Optional, for Actions class
using System.Text;

namespace EinAutomation.Api.Services
{
    public class IRSEinFormFiller : EinFormFiller
    {
        private readonly HttpClient _httpClient;
        private readonly IErrorMessageExtractionService _errorMessageExtractionService;

        public static readonly Dictionary<string, string> EntityTypeMapping = new Dictionary<string, string>
        {
            { "Sole Proprietorship", "Sole Proprietor" },
            { "Individual", "Sole Proprietor" },
            { "Partnership", "Partnership" },
            { "Joint venture", "Partnership" },
            { "Limited Partnership", "Partnership" },
            { "General partnership", "Partnership" },
            { "C-Corporation", "Corporations" },
            { "S-Corporation", "Corporations" },
            { "Professional Corporation", "Corporations" },
            { "Corporation", "Corporations" },
            { "Non-Profit Corporation", "View Additional Types, Including Tax-Exempt and Governmental Organizations" },
            { "Limited Liability", "Limited Liability Company (LLC)" },
            { "Company (LLC)", "Limited Liability Company (LLC)" },
            { "LLC", "Limited Liability Company (LLC)" },
            { "Limited Liability Company", "Limited Liability Company (LLC)" },
            { "Limited Liability Company (LLC)", "Limited Liability Company (LLC)" },
            { "Professional Limited Liability Company", "Limited Liability Company (LLC)" },
            { "Limited Liability Partnership", "Partnership" },
            { "LLP", "Partnership" },
            { "Professional Limited Liability Company (PLLC)", "Limited Liability Company (LLC)" },
            { "Association", "View Additional Types, Including Tax-Exempt and Governmental Organizations" },
            { "Co-ownership", "Partnership" },
            { "Doing Business As (DBA)", "Sole Proprietor" },
            { "Trusteeship", "Trusts" }
        };

        public static readonly Dictionary<string, string> RadioButtonMapping = new Dictionary<string, string>
        {
            { "Sole Proprietor", "sole" },
            { "Partnership", "partnerships" },
            { "Corporations", "corporations" },
            { "Limited Liability Company (LLC)", "limited" },
            { "Estate", "estate" },
            { "Trusts", "trusts" },
            { "View Additional Types, Including Tax-Exempt and Governmental Organizations", "viewadditional" }
        };

        public static readonly Dictionary<string, string> SubTypeMapping = new Dictionary<string, string>
        {
            { "Sole Proprietorship", "Sole Proprietor" },
            { "Individual", "Sole Proprietor" },
            { "Partnership", "Partnership" },
            { "Joint venture", "Joint Venture" },
            { "Limited Partnership", "Partnership" },
            { "General partnership", "Partnership" },
            { "C-Corporation", "Corporation" },
            { "S-Corporation", "S Corporation" },
            { "Professional Corporation", "Personal Service Corporation" },
            { "Corporation", "Corporation" },
            { "Non-Profit Corporation", "Non-Profit/Tax-Exempt Organization" },
            { "Limited Liability", "N/A" },
            { "Limited Liability Company (LLC)", "N/A" },
            { "LLC", "N/A" },
            { "Limited Liability Company", "N/A" },
            { "Professional Limited Liability Company", "N/A" },
            { "Limited Liability Partnership", "Partnership" },
            { "LLP", "Partnership" },
            { "Professional Limited Liability Company (PLLC)", "N/A" },
            { "Association", "N/A" },
            { "Co-ownership", "Partnership" },
            { "Doing Business As (DBA)", "N/A" },
            { "Trusteeship", "Irrevocable Trust" },
            { "Trusteeship-Revocable", "Revocable Trust" },
            { "Trusteeship-Irrevocable", "Irrevocable Trust" }
        };

        public static readonly Dictionary<string, string> SubTypeButtonMapping = new Dictionary<string, string>
        {
            { "Sole Proprietor", "sole" },
            { "Household Employer", "house" },
            { "Partnership", "parnership" },
            { "Joint Venture", "joint" },
            { "Corporation", "corp" },
            { "S Corporation", "scorp" },
            { "Personal Service Corporation", "personalservice" },
            { "Irrevocable Trust", "irrevocable" },
            { "Revocable Trust", "revocable" },
            { "Non-Profit/Tax-Exempt Organization", "othernonprofit" },
            { "Other", "other_option" }
        };

        public IRSEinFormFiller(
            ILogger<IRSEinFormFiller>? logger,
            IBlobStorageService? blobStorageService,
            ISalesforceClient? salesforceClient,
            HttpClient? httpClient,
            IErrorMessageExtractionService errorMessageExtractionService)
            : base(logger ?? throw new ArgumentNullException(nameof(logger)), 
                   blobStorageService ?? throw new ArgumentNullException(nameof(blobStorageService)),
                   salesforceClient)
        {
            _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
            _errorMessageExtractionService = errorMessageExtractionService ?? throw new ArgumentNullException(nameof(errorMessageExtractionService));
        }

        private async Task<bool> DetectAndHandleType2Failure(CaseData? data, Dictionary<string, object?>? jsonData)
        {
            try
            {
                if (Driver == null)
                {
                    _logger.LogError("Cannot detect Type 2 failure - Driver is null");
                    return false;
                }

                var pageText = Driver?.PageSource?.ToLower() ?? string.Empty;
                if (pageText.Contains("we are unable to provide you with an ein"))
                {
                    string? referenceNumber = null;

                    // Primary attempt: Regex
                    var refMatch = Regex.Match(pageText, @"reference number\s+(\d+)");
                    if (refMatch.Success)
                    {
                        referenceNumber = refMatch.Groups[1].Value;
                        _logger.LogInformation("Extracted IRS Reference Number: {ReferenceNumber}", referenceNumber);
                    }
                    else
                    {
                        _logger.LogWarning("Primary reference number extraction failed. Attempting fallback with HtmlAgilityPack.");

                        try
                        {
                            var doc = new HtmlDocument();
                            doc.LoadHtml(Driver?.PageSource ?? string.Empty);

                            var textNodes = doc.DocumentNode.SelectNodes("//text()[contains(., 'reference number')]");
                            if (textNodes != null)
                            {
                                foreach (var node in textNodes)
                                {
                                    var match = Regex.Match(node.InnerText, @"reference number\s+(\d+)");
                                    if (match.Success)
                                    {
                                        referenceNumber = match.Groups[1].Value;
                                        _logger.LogInformation("Extracted IRS Reference Number via fallback: {ReferenceNumber}", referenceNumber);
                                        break;
                                    }
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogError("Fallback parsing of reference number failed: {Message}", ex.Message);
                        }
                    }

                    if (!string.IsNullOrEmpty(referenceNumber))
                    {
                        if (jsonData != null && Driver != null)
                        {
                            var errorMsg = _errorMessageExtractionService.ExtractErrorMessage(Driver);
                            jsonData["irs_reference_number"] = referenceNumber;
                            jsonData["error_message"] = errorMsg;
                            await _blobStorageService.SaveJsonDataSync(jsonData.ToDictionary(kvp => kvp.Key, kvp => kvp.Value ?? new object()));
                        }
                        var (blobUrl, success) = await CaptureFailurePageAsPdf(data, CancellationToken.None);
                        if (success && !string.IsNullOrEmpty(data?.RecordId))
                        {
                            await _salesforceClient.NotifySalesforceErrorCodeAsync(data.RecordId!, referenceNumber, "fail", Driver);
                        }
                        return true;
                    }
                }

                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in DetectAndHandleType2Failure: {ex.Message}");
                return false;
            }
        }
        
        // Helper to remove special characters from addresses
        private static string CleanAddress(string? input)
        {
            if (string.IsNullOrWhiteSpace(input)) return string.Empty;
            // Allow letters, numbers, spaces, hyphen (-), and forward slash (/)
            return Regex.Replace(input, @"[^a-zA-Z0-9\s\-\/]", "");
        }



        public override async Task NavigateAndFillForm(CaseData? data, Dictionary<string, object?>? jsonData)
        {
            try
            {
                LogSystemResources();
                if (data == null)
                {
                    throw new ArgumentNullException(nameof(data));
                }
                if (string.IsNullOrWhiteSpace(data.RecordId))
                {
                    throw new ArgumentNullException(nameof(data.RecordId), "RecordId is required");
                }
                if (string.IsNullOrWhiteSpace(data.FormType))
                {
                    throw new ArgumentNullException(nameof(data.FormType), "FormType is required");
                }
                _logger.LogInformation($"Navigating to IRS EIN form for record_id: {data.RecordId}");
                if (Driver == null)
                {
                    _logger.LogWarning("Driver was null; calling InitializeDriver()");
                    InitializeDriver();

                    if (Driver == null)
                    {
                        _logger.LogCritical("Driver still null after InitializeDriver()");
                        throw new InvalidOperationException("WebDriver is not initialized after InitializeDriver().");
                    }
                }
                Driver.Manage().Timeouts().PageLoad = TimeSpan.FromSeconds(Timeout);
                Driver.Navigate().GoToUrl("https://sa.www4.irs.gov/modiein/individual/index.jsp");
                _logger.LogInformation("Navigated to IRS EIN form");

                try
                {
                    Driver.Manage().Timeouts().PageLoad = TimeSpan.FromSeconds(Timeout);
                    var alert = new WebDriverWait(Driver, TimeSpan.FromSeconds(5)).Until(d =>
                    {
                        try { return d.SwitchTo().Alert(); } catch (NoAlertPresentException) { return null; }
                    });
                    if (alert != null)
                    {
                        var alertText = alert.Text;
                        alert.Accept();
                        _logger.LogInformation($"Handled alert popup: {alertText}");
                    }
                }
                catch (WebDriverTimeoutException)
                {
                    _logger.LogDebug("No alert popup appeared");
                }

                try
                {
                    Driver.Manage().Timeouts().PageLoad = TimeSpan.FromSeconds(Timeout);
                    WaitHelper.WaitUntilExists(Driver, By.XPath("//input[@type='submit' and @name='submit' and @value='Begin Application >>']"), 10);
                    _logger.LogInformation("Page loaded successfully");
                }
                catch (WebDriverTimeoutException)
                {
                    CaptureBrowserLogs();
                    var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                    _logger.LogError($"Page load timeout. Current URL: {Driver?.Url ?? "N/A"}, Page source: {pageSource}");
                    throw new AutomationError("Page load timeout", "Failed to locate Begin Application button");
                }

                if (!ClickButton(By.XPath("//input[@type='submit' and @name='submit' and @value='Begin Application >>']"), "Begin Application"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to click Begin Application", "Button click unsuccessful after retries");
                }

                try
                {
                    Driver.Manage().Timeouts().PageLoad = TimeSpan.FromSeconds(Timeout);
                    WaitHelper.WaitUntilExists(Driver, By.Id("individual-leftcontent"), 10);
                    _logger.LogInformation("Main form content loaded");
                }
                catch (WebDriverTimeoutException)
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to load main form content", "Element 'individual-leftcontent' not found");
                }

                var entityType = data.EntityType?.Trim() ?? string.Empty;
                var mappedType = EntityTypeMapping.GetValueOrDefault(entityType, string.Empty);
                var radioId = RadioButtonMapping.GetValueOrDefault(mappedType, string.Empty);
                if (string.IsNullOrEmpty(radioId) || !SelectRadio(radioId, $"Entity type: {mappedType}"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError($"Failed to select entity type: {mappedType}", $"Radio ID: {radioId}");
                }

                if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after entity type", "Continue button click unsuccessful");
                }

                if (!new[] { "Limited Liability Company (LLC)", "Estate" }.Contains(mappedType))
                {
                    var subType = SubTypeMapping.GetValueOrDefault(entityType, "Other");
                    
                    // Enhanced logic for non-profit organizations
                    if (entityType == "Non-Profit Corporation" || entityType == "Association")
                    {
                        var businessDesc = data.BusinessDescription?.ToLower() ?? string.Empty;
                        var nonprofitKeywords = new[] { "non-profit", "nonprofit", "charity", "charitable", "501(c)", "tax-exempt" };
                        
                        // For Non-Profit Corporation, always use Non-Profit/Tax-Exempt Organization
                        if (entityType == "Non-Profit Corporation")
                        {
                            subType = nonprofitKeywords.Any(keyword => businessDesc.Contains(keyword))
                                ? "Non-Profit/Tax-Exempt Organization"
                                : "Non-Profit/Tax-Exempt Organization"; // Default to non-profit for Non-Profit Corporation
                        }
                        // For Association, check business description to determine if it's non-profit
                        else if (entityType == "Association")
                        {
                            subType = nonprofitKeywords.Any(keyword => businessDesc.Contains(keyword))
                                ? "Non-Profit/Tax-Exempt Organization"
                                : "Other";
                        }
                        
                        _logger.LogInformation("Processing {EntityType} as non-profit organization. Business description: {BusinessDesc}, Selected sub-type: {SubType}", 
                            entityType, businessDesc, subType);
                    }
                    
                    var subTypeRadioId = SubTypeButtonMapping.GetValueOrDefault(subType, "other_option");
                    if (!SelectRadio(subTypeRadioId, $"Sub-type: {subType}"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError($"Failed to select sub-type: {subType}", $"Radio ID: {subTypeRadioId}");
                    }
                    if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue sub-type (first click)"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to continue after sub-type selection (first click)");
                    }
                    await Task.Delay(500);
                    if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue sub-type (second click)"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to continue after sub-type selection (second click)");
                    }
                }
                else
                {
                    if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue after entity type"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to continue after entity type");
                    }
                }

                if (mappedType == "Limited Liability Company (LLC)")
                {
                    // --- numberOfMembers robust handling ---
                    int llcMembers = 1;
                    var llcMembersRaw = data.LlcDetails?.NumberOfMembers;
                    llcMembers = ParseFlexibleInt(llcMembersRaw, 1);
                    if (llcMembers < 1) llcMembers = 1;
                    try
                    {
                        Driver.Manage().Timeouts().PageLoad = TimeSpan.FromSeconds(Timeout);
                        var field = WaitHelper.WaitUntilExists(Driver, By.XPath("//input[@id='numbermem' or @name='numbermem']"), 10);
                        ((IJavaScriptExecutor)Driver).ExecuteScript("arguments[0].scrollIntoView({block: 'center'});", field);
                        field.Clear();
                        await Task.Delay(200);
                        field.SendKeys(llcMembers.ToString());
                        _logger.LogInformation($"Filled LLC members: {llcMembers}");
                    }
                    catch (WebDriverTimeoutException)
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill LLC members", "Timeout waiting for element");
                    }
                    catch (NoSuchElementException ex)
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill LLC members", ex.Message);
                    }
                    var stateValue = NormalizeState(data.EntityState ?? data.EntityStateRecordState ?? string.Empty);
                    if (!SelectDropdown(By.Id("state"), stateValue, "State"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError($"Failed to select state: {stateValue}");
                    }
                    if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to continue after LLC members and state");
                    }
                }

                var specificStates = new HashSet<string> { "AZ", "CA", "ID", "LA", "NV", "NM", "TX", "WA", "WI" };

                if (mappedType == "Limited Liability Company (LLC)" &&
                    specificStates.Contains(NormalizeState(data.EntityState ?? string.Empty)))
                {
                    try
                    {
                        var wait = new WebDriverWait(Driver, TimeSpan.FromSeconds(5));
                        var radioElement = wait.Until(driver =>
                        {
                            var elements = driver.FindElements(By.Id("radio_n"));
                            return elements.Count > 0 ? elements[0] : null;
                        });

                        if (radioElement != null)
                        {
                            if (!SelectRadio("radio_n", "Non-partnership LLC option"))
                            {
                                CaptureBrowserLogs();
                                throw new AutomationError("Failed to select non-partnership LLC option");
                            }

                            if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue after radio_n"))
                            {
                                CaptureBrowserLogs();
                                throw new AutomationError("Failed to continue after non-partnership LLC option");
                            }
                        }
                    }
                    catch (WebDriverTimeoutException)
                    {
                        _logger.LogInformation("'radio_n' not found within 5 seconds. Skipping selection and continuing.");
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning($"Unexpected error while handling non-partnership LLC option: {ex.Message}");
                    }

                    if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue after confirmation"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to continue after confirmation");
                    }
                }
                else
                {
                    if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue after LLC"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to continue after LLC");
                    }
                }

                if (!SelectRadio("newbiz", "New Business"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to select new business");
                }
                if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after business purpose");
                }


                var defaults = GetDefaults(data);
                var firstName = data.EntityMembers?.GetValueOrDefault<string, string>("first_name_1", (string?)defaults["first_name"]!) ?? (string?)defaults["first_name"] ?? string.Empty;
                var lastName = data.EntityMembers?.GetValueOrDefault<string, string>("last_name_1", (string?)defaults["last_name"]!) ?? (string?)defaults["last_name"] ?? string.Empty;
                var middleName = data.EntityMembers?.GetValueOrDefault<string, string>("middle_name_1", (string?)defaults["middle_name"]!) ?? (string?)defaults["middle_name"] ?? string.Empty;

                if (new[] { "Sole Proprietorship", "Individual" }.Contains(data.EntityType ?? string.Empty))
                {
                    if (!FillField(By.Id("applicantFirstName"), firstName, "First Name (Applicant)"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError($"Failed to fill First Name: {firstName}");
                    }
                    if (!string.IsNullOrEmpty(middleName) && !FillField(By.Id("applicantMiddleName"), middleName, "Middle Name (Applicant)"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError($"Failed to fill Middle Name: {middleName}");
                    }
                    if (!FillField(By.Id("applicantLastName"), lastName, "Last Name (Applicant)"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError($"Failed to fill Last Name: {lastName}");
                    }
                }
                else
                {
                    if (!FillField(By.Id("responsiblePartyFirstName"), firstName, "First Name"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError($"Failed to fill First Name: {firstName}");
                    }
                    if (!string.IsNullOrEmpty(middleName) && !FillField(By.Id("responsiblePartyMiddleName"), middleName, "Middle Name"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError($"Failed to fill Middle Name: {middleName}");
                    }
                    if (!FillField(By.Id("responsiblePartyLastName"), lastName, "Last Name"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError($"Failed to fill Last Name: {lastName}");
                    }
                }

                var ssn = (string?)defaults["ssn_decrypted"] ?? string.Empty;
                ssn = ssn.Replace("-", "");
                if (new[] { "Sole Proprietorship", "Individual" }.Contains(data.EntityType ?? string.Empty))
                {
                    if (!FillField(By.Id("applicantSSN3"), ssn.Substring(0, 3), "SSN First 3 (Applicant)"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill SSN First 3");
                    }
                    if (!FillField(By.Id("applicantSSN2"), ssn.Substring(3, 2), "SSN Middle 2 (Applicant)"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill SSN Middle 2");
                    }
                    if (!FillField(By.Id("applicantSSN4"), ssn.Substring(5), "SSN Last 4 (Applicant)"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill SSN Last 4");
                    }
                }
                else
                {
                    if (!FillField(By.Id("responsiblePartySSN3"), ssn.Substring(0, 3), "SSN First 3"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill SSN First 3");
                    }
                    if (!FillField(By.Id("responsiblePartySSN2"), ssn.Substring(3, 2), "SSN Middle 2"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill SSN Middle 2");
                    }
                    if (!FillField(By.Id("responsiblePartySSN4"), ssn.Substring(5), "SSN Last 4"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill SSN Last 4");
                    }
                }

                if (!SelectRadio("iamsole", "I Am Sole"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to select I Am Sole");
                }
                if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after responsible party");
                }



                var address1 = CleanAddress(defaults["business_address_1"]?.ToString()?.Trim() ?? string.Empty);
                var address2 = CleanAddress(defaults["business_address_2"]?.ToString()?.Trim() ?? string.Empty);
                var fullAddress = string.Join(" ", new[] { address1, address2 }.Where(s => !string.IsNullOrEmpty(s)));

                if (!FillField(By.Id("physicalAddressStreet"), fullAddress, "Street"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Physical Street");
                }

                if (!FillField(By.Id("physicalAddressCity"), CleanAddress(defaults["city"]?.ToString()), "Physical City"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Physical City");
                }

                if (!SelectDropdown(By.Id("physicalAddressState"), NormalizeState(data.EntityState ?? string.Empty), "Physical State"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to select Physical State");
                }

                if (!FillField(By.Id("physicalAddressZipCode"), CleanAddress(defaults["zip_code"]?.ToString()), "Physical Zip"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Physical Zip");
                }


                var phone = defaults["phone"]?.ToString() ?? "2812173123";
                var phoneClean = Regex.Replace(phone, @"\D", "");
                if (phoneClean.Length == 10)
                {
                    if (!FillField(By.Id("phoneFirst3"), phoneClean.Substring(0, 3), "Phone First 3"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill Phone First 3");
                    }
                    if (!FillField(By.Id("phoneMiddle3"), phoneClean.Substring(3, 3), "Phone Middle 3"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill Phone Middle 3");
                    }
                    if (!FillField(By.Id("phoneLast4"), phoneClean.Substring(6), "Phone Last 4"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill Phone Last 4");
                    }
                }

                var allowedEntityTypes = new[] { "C-Corporation", "S-Corporation", "Professional Corporation", "Corporation" };
                if (!string.IsNullOrEmpty(data.CareOfName) && allowedEntityTypes.Contains(data.EntityType ?? string.Empty))
                {
                    try
                    {
                        Driver.Manage().Timeouts().PageLoad = TimeSpan.FromSeconds(Timeout);
                        WaitHelper.WaitUntilExists(Driver, By.Id("physicalAddressCareofName"), 10);
                        // Clean the care of name using the same regex rules as legal name
                        var careOfName = data.CareOfName?.Trim() ?? string.Empty;
                        var cleanedCareOfName = Regex.Replace(careOfName, @"[^a-zA-Z0-9\s\-&]", "");
                        
                        _logger.LogInformation("Original care of name: {Original}", careOfName);
                        _logger.LogInformation("Cleaned care of name: {Cleaned}", cleanedCareOfName);
                        
                        if (!FillField(By.Id("physicalAddressCareofName"), cleanedCareOfName, "Physical Care of Name"))
                        {
                            _logger.LogWarning("Failed to fill Physical Care of Name, proceeding");
                        }
                    }
                    catch (WebDriverTimeoutException)
                    {
                        _logger.LogInformation("Physical Care of Name field not found");
                    }
                    catch (NoSuchElementException ex)
                    {
                        _logger.LogInformation($"Physical Care of Name field not found: {ex.Message}");
                    }
                }

                // Support MailingAddress as array
                var mailingAddressDict = (data.MailingAddress != null && data.MailingAddress.Count > 0)
                    ? data.MailingAddress[0]
                    : new Dictionary<string, string>();

                var mailingStreet = mailingAddressDict.GetValueOrDefault("mailingStreet", "").Trim();
                var physicalStreet1 = defaults["business_address_1"]?.ToString()?.Trim() ?? string.Empty;
                var physicalStreet2 = defaults["business_address_2"]?.ToString()?.Trim() ?? string.Empty;
                var physicalFullAddress = string.Join(" ", new[] { physicalStreet1, physicalStreet2 }.Where(s => !string.IsNullOrEmpty(s))).Trim();

                var shouldFillMailing = !string.IsNullOrEmpty(mailingStreet) &&
                                        !string.Equals(mailingStreet, physicalFullAddress, StringComparison.OrdinalIgnoreCase);

                if (shouldFillMailing)
                {
                    if (!SelectRadio("radioAnotherAddress_y", "Address option (Yes)"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to select Address option (Yes)");
                    }
                }
                else
                {
                    if (!SelectRadio("radioAnotherAddress_n", "Address option (No)"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to select Address option (No)");
                    }
                }

                if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue after address option"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after address option");
                }

                try
                {
                    var shortWait = new WebDriverWait(Driver, TimeSpan.FromSeconds(20));
                    var element = WaitHelper.WaitUntilClickable(Driver, By.XPath("//input[@type='submit' and @name='Submit' and @value='Accept As Entered']"), 20);
                    ((IJavaScriptExecutor)Driver).ExecuteScript("arguments[0].scrollIntoView({block: 'center'});", element);
                    element.Click();
                    _logger.LogInformation("Clicked Accept As Entered");
                }
                catch (WebDriverTimeoutException)
                {
                    _logger.LogInformation("Accept As Entered button not found within 20 seconds, proceeding.");
                }
                catch (Exception ex)
                {
                    _logger.LogWarning($"Unexpected error while clicking Accept As Entered: {ex.Message}");
                }

                if (shouldFillMailing)
                {
                    if (!FillField(By.Id("mailingAddressStreet"), CleanAddress(mailingStreet), "Mailing Street"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill Mailing Street");
                    }
                    if (!FillField(By.Id("mailingAddressCity"), CleanAddress(mailingAddressDict.GetValueOrDefault("mailingCity", "")), "Mailing City"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill Mailing City");
                    }
                    if (!FillField(By.Id("mailingAddressState"), CleanAddress(mailingAddressDict.GetValueOrDefault("mailingState", "")), "Mailing State"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to select Mailing State");
                    }
                    if (!FillField(By.Id("mailingAddressPostalCode"), CleanAddress(mailingAddressDict.GetValueOrDefault("mailingZip", "")), "Zip"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to fill Mailing Zip");
                    }
                    if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue after mailing address"))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError("Failed to continue after mailing address");
                    }
                    try
                    {
                        var shortWait = new WebDriverWait(Driver, TimeSpan.FromSeconds(20));
                        var element = WaitHelper.WaitUntilClickable(Driver, By.XPath("//input[@type='submit' and @name='Submit' and @value='Accept As Entered']"), 20);
                        ((IJavaScriptExecutor)Driver).ExecuteScript("arguments[0].scrollIntoView({block: 'center'});", element);
                        element.Click();
                        _logger.LogInformation("Clicked Accept As Entered");
                    }
                    catch (WebDriverTimeoutException)
                    {
                        _logger.LogInformation("Accept As Entered button not found within 20 seconds, proceeding.");
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning($"Unexpected error while clicking Accept As Entered: {ex.Message}");
                    }
                }


                var suffixRulesByGroup = new Dictionary<string, string[]>
                {
                    {"sole", new[] {"LLC", "LC", "PLLC", "PA", "Corp", "Inc"}},
                    {"partnerships", new[] {"Corp", "LLC", "PLLC", "LC", "Inc", "PA"}},
                    {"corporations", new[] {"LLC", "PLLC", "LC"}},
                    {"limited", new[] {"Corp", "Inc", "PA"}},
                    {"trusts", new[] {"Corp", "LLC", "PLLC", "LC", "Inc", "PA"}},
                    {"estate", new[] {"Corp", "LLC", "PLLC", "LC", "Inc", "PA"}},
                    {"othernonprofit", new[] {"Corp", "Inc", "PA"}}
                };

                string? businessName;
                try
                {
                    businessName = ((string?)defaults["entity_name"] ?? string.Empty).Trim();
                    var originalName = businessName;

                    var entityTypeLabel = data.EntityType?.Trim() ?? string.Empty;
                    mappedType = EntityTypeMapping.GetValueOrDefault(entityTypeLabel, string.Empty).Trim();
                    var entityGroup = RadioButtonMapping.GetValueOrDefault(mappedType);

                    if (!string.IsNullOrEmpty(entityGroup))
                    {
                        var suffixes = suffixRulesByGroup.GetValueOrDefault(entityGroup, new string[] { });
                        foreach (var suffix in suffixes)
                        {
                            if (Regex.IsMatch(businessName, $@"\b{suffix}\s*$", RegexOptions.IgnoreCase))
                            {
                                businessName = Regex.Replace(businessName, $@"\b{suffix}\s*$", "", RegexOptions.IgnoreCase).Trim();
                                _logger.LogInformation($"Stripped suffix '{suffix}' from business name: '{originalName}' -> '{businessName}'");
                                break;
                            }
                        }
                    }

                    businessName = Regex.Replace(businessName, @"[^a-zA-Z0-9\s\-&]", "");
                }
                catch (Exception ex)
                {
                    _logger.LogError($"Failed to process business name: {ex.Message}");
                    businessName = ((string?)defaults["entity_name"] ?? string.Empty).Trim();
                }

                try
                {
                    var entityGroup = RadioButtonMapping.GetValueOrDefault(mappedType);
                    if (entityGroup == "sole")
                    {
                        if (!FillField(By.Id("businessOperationalTradeName"), businessName, "Trade Name (Sole Prop/Individual)"))
                        {
                            _logger.LogInformation("Failed to fill business name in trade name field");
                        }
                    }
                    else
                    {
                        if (!FillField(By.Id("businessOperationalLegalName"), businessName, "Legal Business Name"))
                        {
                            _logger.LogInformation("Failed to fill business name in legal name field");
                        }
                    }
                }
                catch (WebDriverTimeoutException)
                {
                    _logger.LogInformation("Business name field not found");
                }
                catch (NoSuchElementException ex)
                {
                    _logger.LogInformation($"Business name field not found: {ex.Message}");
                }

                if (!FillField(By.Id("businessOperationalCounty"), data.County ?? string.Empty, "County"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill County");
                }

                try
                {
                    SelectDropdown(By.Id("businessOperationalState"), NormalizeState(data.EntityState ?? string.Empty), "Business Operational State");
                }
                catch (WebDriverTimeoutException)
                {
                    _logger.LogInformation("Business Operational State dropdown not found");
                }
                catch (NoSuchElementException ex)
                {
                    _logger.LogInformation($"Business Operational State dropdown not found: {ex.Message}");
                }

                
                var filingState = data.FilingState;
                var entityTypesRequiringArticles = new[] { "C-Corporation", "S-Corporation", "Professional Corporation", "Corporation", "Limited Liability Company", "Professional Limited Liability Company", "Limited Liability Company (LLC)", "Professional Limited Liability Company (PLLC)", "LLC" };
                if (entityTypesRequiringArticles.Contains(data.EntityType ?? string.Empty))
                {
                    try
                    {   _logger.LogInformation("Attempting to select Articles Filed State. FilingState value: '{FilingState}'", filingState);
                        SelectDropdown(By.Id("articalsFiledState"), NormalizeState(data.FilingState ?? string.Empty), "Articles Filed State");
                        _logger.LogInformation("Selected Articles Filed State");
                    }
                    catch (WebDriverTimeoutException)
                    {
                        _logger.LogInformation("Articles Filed State dropdown not found");
                    }
                    catch (NoSuchElementException ex)
                    {
                        _logger.LogInformation($"Articles Filed State dropdown not found: {ex.Message}");
                    }
                }

                try
                {
                    if (!string.IsNullOrEmpty(data.TradeName))
                    {
                        var tradeName = data.TradeName?.Trim() ?? string.Empty;
                        var entityName = (string?)defaults["entity_name"] ?? string.Empty;

                        var entityTypeLabel = data.EntityType?.Trim() ?? string.Empty;
                        var localMappedType = EntityTypeMapping.GetValueOrDefault(entityTypeLabel, string.Empty).Trim();
                        var entityGroup = RadioButtonMapping.GetValueOrDefault(mappedType, "");

                        var suffixesByGroup = new Dictionary<string, string[]>
                {
                    {"sole", new[] {"LLC", "LC", "PLLC", "PA", "Corp", "Inc"}},
                    {"partnerships", new[] {"LLC", "LC", "PLLC", "PA", "Corp", "Inc"}},
                    {"corporations", new[] {"LLC", "LC", "PLLC", "PA", "Corp", "Inc"}},
                    {"limited", new[] {"LLC", "LC", "PLLC", "PA", "Corp", "Inc"}},
                    {"trusts", new[] {"LLC", "LC", "PLLC", "PA", "Corp", "Inc"}},
                    {"estate", new[] {"LLC", "LC", "PLLC", "PA", "Corp", "Inc"}},
                    {"othernonprofit", new[] {"LLC", "LC", "PLLC", "PA", "Corp", "Inc"}}
                };

                        string NormalizeName(string name, string group)
                        {
                            string result = Regex.Replace(name, @"[^a-zA-Z0-9\s\-&]", "").Trim();
                            var suffixes = suffixesByGroup.GetValueOrDefault(group, new string[] { });

                            foreach (var suffix in suffixes)
                            {
                                if (Regex.IsMatch(result, $@"\b{suffix}\s*$", RegexOptions.IgnoreCase))
                                {
                                    result = Regex.Replace(result, $@"\b{suffix}\s*$", "", RegexOptions.IgnoreCase).Trim();
                                    break;
                                }
                            }

                            return result;
                        }

                        var normalizedTrade = NormalizeName(tradeName, entityGroup);
                        var normalizedEntity = NormalizeName(entityName, entityGroup);

                        if (!string.Equals(normalizedTrade, normalizedEntity, StringComparison.OrdinalIgnoreCase))
                        {
                            _logger.LogInformation($"Filling Trade Name since it differs from Entity Name: '{normalizedTrade}' != '{normalizedEntity}'");

                            if (!FillField(By.Id("businessOperationalTradeName"), normalizedTrade, "Trade Name"))
                            {
                                CaptureBrowserLogs();
                                throw new AutomationError("Failed to fill Trade Name");
                            }
                        }
                        else
                        {
                            _logger.LogInformation("Skipping Trade Name input as it's same as Entity Name after normalization.");
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning($"Could not process or fill Trade Name: {ex.Message}");
                }


                // --- startDate robust handling ---
                var (month, year) = ParseFlexibleDate(data?.FormationDate ?? string.Empty);
                if (!SelectDropdown(By.Id("BUSINESS_OPERATIONAL_MONTH_ID"), month?.ToString(), "Formation Month"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to select Formation Month");
                }
                if (!FillField(By.Id("BUSINESS_OPERATIONAL_YEAR_ID"), year.ToString(), "Formation Year"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Formation Year");
                }

                // --- closingMonth robust handling ---
                string closingMonthRaw = data?.ClosingMonth?.ToString() ?? string.Empty;
                if (int.TryParse(closingMonthRaw, out var closingMonthInt))
                    closingMonthRaw = closingMonthInt.ToString();

                if (!string.IsNullOrEmpty(closingMonthRaw))
                {
                    var monthMapping = new Dictionary<string, string>
                    {
                        {"january", "JANUARY"}, {"jan", "JANUARY"}, {"1", "JANUARY"},
                        {"february", "FEBRUARY"}, {"feb", "FEBRUARY"}, {"2", "FEBRUARY"},
                        {"march", "MARCH"}, {"mar", "MARCH"}, {"3", "MARCH"},
                        {"april", "APRIL"}, {"apr", "APRIL"}, {"4", "APRIL"},
                        {"may", "MAY"}, {"5", "MAY"},
                        {"june", "JUNE"}, {"jun", "JUNE"}, {"6", "JUNE"},
                        {"july", "JULY"}, {"jul", "JULY"}, {"7", "JULY"},
                        {"august", "AUGUST"}, {"aug", "AUGUST"}, {"8", "AUGUST"},
                        {"september", "SEPTEMBER"}, {"sep", "SEPTEMBER"}, {"9", "SEPTEMBER"},
                        {"october", "OCTOBER"}, {"oct", "OCTOBER"}, {"10", "OCTOBER"},
                        {"november", "NOVEMBER"}, {"nov", "NOVEMBER"}, {"11", "NOVEMBER"},
                        {"december", "DECEMBER"}, {"dec", "DECEMBER"}, {"12", "DECEMBER"}
                    };

                    var entityTypesRequiringFiscalMonth = new[] { "Partnership", "Joint venture", "Limited Partnership", "General partnership", "C-Corporation", "Limited Liability Partnership", "LLP", "Corporation" };

                    if (entityTypesRequiringFiscalMonth.Contains(data.EntityType ?? string.Empty))
                    {
                        var normalizedMonth = monthMapping.GetValueOrDefault(closingMonthRaw.ToLower().Trim());
                        if (!string.IsNullOrEmpty(normalizedMonth))
                        {
                            const int retries = 2;
                            for (int attempt = 0; attempt < retries; attempt++)
                            {
                                try
                                {
                                    Driver.Manage().Timeouts().PageLoad = TimeSpan.FromSeconds(Timeout);
                                    var dropdown = WaitHelper.WaitUntilClickable(Driver, By.Id("fiscalMonth"), 10);
                                    new SelectElement(dropdown).SelectByText(normalizedMonth);
                                    _logger.LogInformation($"Selected Fiscal Month: {normalizedMonth}");
                                    break;
                                }
                                catch (WebDriverTimeoutException)
                                {
                                    if (attempt < retries - 1)
                                    {
                                        _logger.LogWarning($"Attempt {attempt + 1} to select Fiscal Month failed");
                                        await Task.Delay(1000);
                                    }
                                    else
                                    {
                                        CaptureBrowserLogs();
                                        throw new AutomationError($"Failed to select Fiscal Month {normalizedMonth}");
                                    }
                                }
                                catch (NoSuchElementException ex)
                                {
                                    if (attempt < retries - 1)
                                    {
                                        _logger.LogWarning($"Attempt {attempt + 1} to select Fiscal Month failed: {ex.Message}");
                                        await Task.Delay(1000);
                                    }
                                    else
                                    {
                                        CaptureBrowserLogs();
                                        throw new AutomationError($"Failed to select Fiscal Month {normalizedMonth}", ex.Message);
                                    }
                                }
                                catch (StaleElementReferenceException ex)
                                {
                                    if (attempt < retries - 1)
                                    {
                                        _logger.LogWarning($"Attempt {attempt + 1} to select Fiscal Month failed: {ex.Message}");
                                        await Task.Delay(1000);
                                    }
                                    else
                                    {
                                        CaptureBrowserLogs();
                                        throw new AutomationError($"Failed to select Fiscal Month {normalizedMonth}", ex.Message);
                                    }
                                }
                            }
                        }
                        else
                        {
                            _logger.LogWarning($"Invalid closing_month: {closingMonthRaw}, skipping");
                        }
                    }
                    else
                    {
                        _logger.LogInformation($"Skipping fiscal month selection for entity_type: {data.EntityType}");
                    }
                }

                if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after formation date");
                }

                var activityRadios = new[] { "radioTrucking_n", "radioInvolveGambling_n", "radioExciseTax_n", "radioSellTobacco_n", "radioHasEmployees_n" };
                foreach (var radio in activityRadios)
                {
                    if (!SelectRadio(radio, radio))
                    {
                        CaptureBrowserLogs();
                        throw new AutomationError($"Failed to select {radio}");
                    }
                }
                if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after activity options");
                }

                if (!SelectRadio("other", "Other activity"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to select Other activity");
                }
                if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after primary activity");
                }

                if (!SelectRadio("other", "Other service"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to select Other service");
                }
                // Clean the business description to remove special characters
                var businessDescription = defaults["business_description"]?.ToString();
                var cleanedBusinessDescription = CleanBusinessDescription(businessDescription);
                
                _logger.LogInformation("Original business description: {Original}", businessDescription);
                _logger.LogInformation("Cleaned business description: {Cleaned}", cleanedBusinessDescription);
                
                if (!FillField(By.Id("pleasespecify"), cleanedBusinessDescription, "Business Description"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Business Description");
                }
                if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after specify service");
                }

                if (!SelectRadio("receiveonline", "Receive Online"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to select Receive Online");
                }

                if (ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue after receive EIN"))
                {
                    CaptureBrowserLogs();
                    var (blobUrl, success) = await CapturePageAsPdfEnhanced(data, CancellationToken.None);

                    if (success && !string.IsNullOrEmpty(blobUrl))
                    {
                        _logger.LogInformation($"Confirmation screenshot uploaded to Azure: {blobUrl}");
                    }
                    else
                    {
                        _logger.LogError("Failed to capture and upload EIN confirmation PDF.");
                    }
                }
                else
                {
                    throw new AutomationError("Failed to continue after receive EIN selection");
                }

                _logger.LogInformation("Form filled successfully");
            }
            catch (WebDriverTimeoutException ex)
            {
                CaptureBrowserLogs();
                var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                _logger.LogError($"Form filling error at URL: {Driver?.Url ?? "N/A"}, Error: {ex.Message}, Page source: {pageSource}");
                throw new AutomationError("Form filling error", ex.Message);
            }
            catch (NoSuchElementException ex)
            {
                CaptureBrowserLogs();
                var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                _logger.LogError($"Form filling error at URL: {Driver?.Url ?? "N/A"}, Error: {ex.Message}, Page source: {pageSource}");
                throw new AutomationError("Form filling error", ex.Message);
            }
            catch (ElementNotInteractableException ex)
            {
                CaptureBrowserLogs();
                var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                _logger.LogError($"Form filling error at URL: {Driver?.Url ?? "N/A"}, Error: {ex.Message}, Page source: {pageSource}");
                throw new AutomationError("Form filling error", ex.Message);
            }
            catch (StaleElementReferenceException ex)
            {
                CaptureBrowserLogs();
                var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                _logger.LogError($"Form filling error at URL: {Driver?.Url ?? "N/A"}, Error: {ex.Message}, Page source: {pageSource}");
                throw new AutomationError("Form filling error", ex.Message);
            }
            catch (WebDriverException ex)
            {
                CaptureBrowserLogs();
                if (File.Exists(DriverLogPath))
                {
                    try
                    {
                        var driverLogs = await File.ReadAllTextAsync(DriverLogPath);
                        _logger.LogError($"ChromeDriver logs: {driverLogs}");
                    }
                    catch (Exception logEx)
                    {
                        _logger.LogError($"Failed to read ChromeDriver logs: {logEx.Message}");
                    }
                }
                var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                _logger.LogError($"WebDriver error during form filling at URL: {Driver?.Url ?? "N/A"}, Error: {ex.Message}, Page source: {pageSource}");
                throw new AutomationError("WebDriver error", ex.Message);
            }
            catch (Exception ex)
            {
                CaptureBrowserLogs();
                var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                _logger.LogError($"Unexpected error during form filling at URL: {Driver?.Url ?? "N/A"}, Error: {ex.Message}, Page source: {pageSource}");

                try
                {
                    var handled = await DetectAndHandleType2Failure(data, jsonData);
                    if (handled)
                    {
                        _logger.LogWarning("Handled as Type 2 EIN failure during form fill. Skipping exception raise.");
                        return;
                    }
                }
                catch (Exception err)
                {
                    _logger.LogError($"Type 2 handler failed while processing EIN failure page: {err.Message}");
                }

                throw new AutomationError("Unexpected form filling error", ex.Message);
            }

        }

        public override async Task HandleTrusteeshipEntity(CaseData? data)
        {
            _logger.LogInformation("Handling Trusteeship entity type form flow");
            if (data == null)
            {
                throw new ArgumentNullException(nameof(data));
            }
            if (string.IsNullOrWhiteSpace(data.EntityType))
            {
                throw new ArgumentNullException(nameof(data.EntityType), "EntityType is required");
            }
            var defaults = GetDefaults(data);

            try
            {
                LogSystemResources();
                _logger.LogInformation($"Navigating to IRS EIN form for record_id: {data.RecordId}");
                if (Driver == null)
                {
                    _logger.LogWarning("Driver was null; calling InitializeDriver()");
                    InitializeDriver();

                    if (Driver == null)
                    {
                        _logger.LogCritical("Driver still null after InitializeDriver()");
                        throw new InvalidOperationException("WebDriver is not initialized after InitializeDriver().");
                    }
                }
                Driver.Manage().Timeouts().PageLoad = TimeSpan.FromSeconds(Timeout);
                Driver.Navigate().GoToUrl("https://sa.www4.irs.gov/modiein/individual/index.jsp");
                _logger.LogInformation("Navigated to IRS EIN form");

                try
                {
                    Driver.Manage().Timeouts().PageLoad = TimeSpan.FromSeconds(Timeout);
                    var alert = new WebDriverWait(Driver, TimeSpan.FromSeconds(5)).Until(d =>
                    {
                        try { return d.SwitchTo().Alert(); } catch (NoAlertPresentException) { return null; }
                    });
                    if (alert != null)
                    {
                        var alertText = alert.Text;
                        alert.Accept();
                        _logger.LogInformation($"Handled alert popup: {alertText}");
                    }
                }
                catch (WebDriverTimeoutException)
                {
                    _logger.LogDebug("No alert popup appeared");
                }

                try
                {
                    Driver.Manage().Timeouts().PageLoad = TimeSpan.FromSeconds(Timeout);
                    WaitHelper.WaitUntilExists(Driver, By.XPath("//input[@type='submit' and @name='submit' and @value='Begin Application >>']"), 10);
                    _logger.LogInformation("Page loaded successfully");
                }
                catch (WebDriverTimeoutException)
                {
                    CaptureBrowserLogs();
                    var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                    _logger.LogError($"Page load timeout. Current URL: {Driver?.Url ?? "N/A"}, Page source: {pageSource}");
                    throw new AutomationError("Page load timeout", "Failed to locate Begin Application button");
                }

                if (!ClickButton(By.XPath("//input[@type='submit' and @name='submit' and @value='Begin Application >>']"), "Begin Application"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to click Begin Application", "Button click unsuccessful after retries");
                }

                try
                {
                    Driver.Manage().Timeouts().PageLoad = TimeSpan.FromSeconds(Timeout);
                    WaitHelper.WaitUntilExists(Driver, By.Id("individual-leftcontent"), 10);
                    _logger.LogInformation("Main form content loaded");
                }
                catch (WebDriverTimeoutException)
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to load main form content", "Element 'individual-leftcontent' not found");
                }

                var entityType = data.EntityType?.Trim() ?? string.Empty;
                var mappedType = EntityTypeMapping.GetValueOrDefault(entityType, "Trusts");
                _logger.LogInformation($"Mapped entity type: {entityType} -> {mappedType}");
                var radioId = RadioButtonMapping.GetValueOrDefault(mappedType);
                if (string.IsNullOrEmpty(radioId) || !SelectRadio(radioId, $"Entity type: {mappedType}"))
                {
                    throw new AutomationError("Failed to select Trusteeship entity type");
                }

                if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue after entity type"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after entity type");
                }

                // Determine sub-type based on TrustType from payload
                string subType;
                if (entityType == "Trusteeship")
                {
                    var trustType = data.TrustType?.Trim() ?? string.Empty;
                    _logger.LogInformation($"TrustType from payload: {trustType}");
                    
                    if (trustType.Equals("Revocable", StringComparison.OrdinalIgnoreCase))
                    {
                        subType = "Revocable Trust";
                        _logger.LogInformation("Selected Revocable Trust sub-type based on TrustType: Revocable");
                    }
                    else if (trustType.Equals("Irrevocable", StringComparison.OrdinalIgnoreCase))
                    {
                        subType = "Irrevocable Trust";
                        _logger.LogInformation("Selected Irrevocable Trust sub-type based on TrustType: Irrevocable");
                    }
                    else
                    {
                        // Default to Irrevocable Trust if TrustType is not specified or invalid
                        subType = "Irrevocable Trust";
                        _logger.LogWarning($"Invalid or missing TrustType: '{trustType}'. Defaulting to Irrevocable Trust");
                    }
                }
                else
                {
                    subType = SubTypeMapping.GetValueOrDefault(entityType, "Other");
                }
                
                var subRadioId = SubTypeButtonMapping.GetValueOrDefault(subType, "other_option");
                if (!SelectRadio(subRadioId, $"Sub-type: {subType}"))
                {
                    throw new AutomationError("Failed to select Trusteeship sub-type");
                }

                if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue after sub-type"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after sub-type");
                }
                CaptureBrowserLogs();
                if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue after sub-type"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after sub-type");
                }
                CaptureBrowserLogs();

                if (!FillField(By.XPath("//input[@id='responsiblePartyFirstName']"), (string?)defaults["first_name"] ?? string.Empty, "Responsible First Name"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Responsible First Name");
                }
                CaptureBrowserLogs();

                if (!string.IsNullOrEmpty((string?)defaults["middle_name"]) && !FillField(By.XPath("//input[@id='responsiblePartyMiddleName']"), (string?)defaults["middle_name"] ?? string.Empty, "Responsible Middle Name"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Responsible Middle Name");
                }
                CaptureBrowserLogs();

                if (!FillField(By.XPath("//input[@id='responsiblePartyLastName']"), (string?)defaults["last_name"] ?? string.Empty, "Responsible Last Name"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Responsible Last Name");
                }
                CaptureBrowserLogs();

                var ssn = (string?)defaults["ssn_decrypted"] ?? string.Empty;
                ssn = ssn.Replace("-", "");
                if (!FillField(By.XPath("//input[@id='responsiblePartySSN3']"), ssn.Substring(0, 3), "SSN First 3"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill SSN First 3");
                }
                CaptureBrowserLogs();
                if (!FillField(By.XPath("//input[@id='responsiblePartySSN2']"), ssn.Substring(3, 2), "SSN Middle 2"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill SSN Middle 2");
                }
                CaptureBrowserLogs();
                if (!FillField(By.XPath("//input[@id='responsiblePartySSN4']"), ssn.Substring(5), "SSN Last 4"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill SSN Last 4");
                }
                CaptureBrowserLogs();

                if (!ClickButton(By.XPath("//input[@type='submit' and @name='Submit2' and contains(@value, 'Continue >>')]"), "Continue after SSN"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after SSN");
                }
                CaptureBrowserLogs();

                FillField(By.XPath("//input[@id='responsiblePartyFirstName']"), (string?)defaults["first_name"] ?? string.Empty, "Clear & Fill First Name");
                CaptureBrowserLogs();
                if (!string.IsNullOrEmpty((string?)defaults["middle_name"]))
                {
                    FillField(By.XPath("//input[@id='responsiblePartyMiddleName']"), (string?)defaults["middle_name"] ?? string.Empty, "Responsible Middle Name");
                }
                CaptureBrowserLogs();
                FillField(By.XPath("//input[@id='responsiblePartyLastName']"), (string?)defaults["last_name"] ?? string.Empty, "Clear & Fill Last Name");
                CaptureBrowserLogs();

                if (!SelectRadio("iamsole", "I Am Sole"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to select I Am Sole");
                }
                CaptureBrowserLogs();
                if (!ClickButton(By.XPath("//input[@type='submit' and @name='Submit' and contains(@value, 'Continue >>')]"), "Continue after I Am Sole"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after I Am Sole");
                }
                CaptureBrowserLogs();

                // Trusteeship entity: update mailing address usage
                var mailingAddressDict = (data.MailingAddress != null && data.MailingAddress.Count > 0)
                    ? data.MailingAddress[0]
                    : new Dictionary<string, string>();

                if (!FillField(By.XPath("//input[@id='mailingAddressStreet']"),
                    CleanAddress(mailingAddressDict.GetValueOrDefault("mailingStreet", "")),
                    "Mailing Street"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Mailing Street");
                }
                CaptureBrowserLogs();

                if (!FillField(By.XPath("//input[@id='mailingAddressCity']"),
                    CleanAddress(mailingAddressDict.GetValueOrDefault("mailingCity", "")),
                    "Mailing City"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Mailing City");
                }
                CaptureBrowserLogs();

                if (!FillField(By.XPath("//input[@id='mailingAddressState']"),
                    CleanAddress(mailingAddressDict.GetValueOrDefault("mailingState", "")),
                    "Mailing State"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Mailing State");
                }
                CaptureBrowserLogs();

                if (!FillField(By.XPath("//input[@id='mailingAddressPostalCode']"),
                    CleanAddress(mailingAddressDict.GetValueOrDefault("mailingZip", "")),
                    "Zip"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Zip");
                }
                CaptureBrowserLogs();

                if (!FillField(By.XPath("//input[@id='internationalPhoneNumber']"), (string?)defaults["phone"] ?? string.Empty, "Phone Number"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Phone Number");
                }
                CaptureBrowserLogs();

                if (!ClickButton(By.XPath("//input[@type='submit' and @name='Submit' and contains(@value, 'Continue >>')]"), "Continue after Mailing"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after Mailing");
                }
                CaptureBrowserLogs();

                try
                {
                    var shortWait = new WebDriverWait(Driver, TimeSpan.FromSeconds(20));
                    var element = WaitHelper.WaitUntilClickable(Driver, By.XPath("//input[@type='submit' and @name='Submit' and @value='Accept As Entered']"), 20);
                    ((IJavaScriptExecutor)Driver).ExecuteScript("arguments[0].scrollIntoView({block: 'center'});", element);
                    element.Click();
                    _logger.LogInformation("Clicked Accept As Entered");
                }
                catch (WebDriverTimeoutException)
                {
                    _logger.LogInformation("Accept As Entered button not found within 20 seconds, proceeding.");
                }
                catch (Exception ex)
                {
                    _logger.LogWarning($"Unexpected error while clicking Accept As Entered: {ex.Message}");
                }

                string? businessName;
                try
                {
                    businessName = ((string?)defaults["entity_name"] ?? string.Empty).Trim();
                    businessName = Regex.Replace(businessName, @"[^a-zA-Z0-9\s\-&]", "");
                    var suffixes = new[] { "Corp", "Inc", "LLC", "LC", "PLLC", "PA", "L.L.C.", "INC.", "CORPORATION", "LIMITED" };
                    var pattern = $@"\b(?:{string.Join("|", suffixes.Select(Regex.Escape))})\b\.?$";
                    businessName = Regex.Replace(businessName, pattern, "", RegexOptions.IgnoreCase).Trim();
                }
                catch (Exception ex)
                {
                    _logger.LogError($"Failed to process business name: {ex.Message}");
                    businessName = ((string?)defaults["entity_name"] ?? string.Empty).Trim();
                }

                try
                {
                    if (!FillField(By.Id("businessOperationalLegalName"), businessName, "Legal Business Name"))
                    {
                        _logger.LogInformation("Failed to fill business name in appropriate field based on entity type");
                    }
                }
                catch (WebDriverTimeoutException)
                {
                    _logger.LogInformation("Business name field not found");
                }
                catch (NoSuchElementException ex)
                {
                    _logger.LogInformation($"Business name field not found: {ex.Message}");
                }

                if (!FillField(By.XPath("//input[@id='businessOperationalCounty']"), data.County ?? string.Empty, "County"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill County");
                }
                CaptureBrowserLogs();

                try
            {
                var normalizedState = NormalizeState(data.EntityState ?? string.Empty);
                var stateSelect = WaitHelper.WaitUntilClickable(Driver, By.XPath("//select[@id='businessOperationalState' and @name='businessOperationalState']"), 10);
                new SelectElement(stateSelect).SelectByValue(normalizedState);
                _logger.LogInformation($"Selected state: {normalizedState}");
            }
            catch (WebDriverTimeoutException)
            {
                CaptureBrowserLogs();
                throw new AutomationError("Failed to select state");
            }
            catch (NoSuchElementException ex)
            {
                CaptureBrowserLogs();
                throw new AutomationError($"Failed to select state: {ex.Message}");
            }
            CaptureBrowserLogs();


                var (month, year) = ParseFlexibleDate(data.FormationDate ?? string.Empty);
                if (!SelectDropdown(By.Id("BUSINESS_OPERATIONAL_MONTH_ID"), month.ToString(), "Formation Month"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to select Formation Month");
                }
                if (!FillField(By.Id("BUSINESS_OPERATIONAL_YEAR_ID"), year.ToString(), "Formation Year"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to fill Formation Year");
                }

                if (!ClickButton(By.XPath("//input[@type='submit' and @name='Submit' and contains(@value, 'Continue >>')]"), "Continue after Business Info"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after Business Info");
                }
                CaptureBrowserLogs();

                if (!SelectRadio("radioHasEmployees_n", "radioHasEmployees_n"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to select radioHasEmployees_n");
                }
                if (!ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to continue after activity options");
                }
                CaptureBrowserLogs();

                if (!SelectRadio("receiveonline", "Receive Online"))
                {
                    CaptureBrowserLogs();
                    throw new AutomationError("Failed to select Receive Online");
                }

                if (ClickButton(By.XPath("//input[@type='submit' and @value='Continue >>']"), "Continue after receive EIN"))
                {
                    CaptureBrowserLogs();
                    var (blobUrl, success) = await CapturePageAsPdfEnhanced(data, CancellationToken.None);

                    if (success && !string.IsNullOrEmpty(blobUrl))
                    {
                        _logger.LogInformation($"Confirmation screenshot uploaded to Azure: {blobUrl}");
                    }
                    else
                    {
                        _logger.LogError("Failed to capture and upload EIN confirmation PDF.");
                    }
                }
                else
                {
                    throw new AutomationError("Failed to continue after receive EIN selection");
                }

                _logger.LogInformation("Form filled successfully");
                _logger.LogInformation("Completed Trusteeship entity form successfully");
            }
            catch (WebDriverTimeoutException ex)
            {
                CaptureBrowserLogs();
                var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                _logger.LogError($"Form filling error at URL: {Driver?.Url ?? "N/A"}, Error: {ex.Message}, Page source: {pageSource}");
                throw new AutomationError("Form filling error", ex.Message);
            }
            catch (NoSuchElementException ex)
            {
                CaptureBrowserLogs();
                var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                _logger.LogError($"Form filling error at URL: {Driver?.Url ?? "N/A"}, Error: {ex.Message}, Page source: {pageSource}");
                throw new AutomationError("Form filling error", ex.Message);
            }
            catch (ElementNotInteractableException ex)
            {
                CaptureBrowserLogs();
                var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                _logger.LogError($"Form filling error at URL: {Driver?.Url ?? "N/A"}, Error: {ex.Message}, Page source: {pageSource}");
                throw new AutomationError("Form filling error", ex.Message);
            }
            catch (StaleElementReferenceException ex)
            {
                CaptureBrowserLogs();
                var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                _logger.LogError($"Form filling error at URL: {Driver?.Url ?? "N/A"}, Error: {ex.Message}, Page source: {pageSource}");
                throw new AutomationError("Form filling error", ex.Message);
            }
            catch (WebDriverException ex)
            {
                CaptureBrowserLogs();
                if (File.Exists(DriverLogPath))
                {
                    try
                    {
                        var driverLogs = await File.ReadAllTextAsync(DriverLogPath);
                        _logger.LogError($"ChromeDriver logs: {driverLogs}");
                    }
                    catch (Exception logEx)
                    {
                        _logger.LogError($"Failed to read ChromeDriver logs: {logEx.Message}");
                    }
                }
                var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                _logger.LogError($"WebDriver error during form filling at URL: {Driver?.Url ?? "N/A"}, Error: {ex.Message}, Page source: {pageSource}");
                throw new AutomationError("WebDriver error", ex.Message);
            }
            catch (Exception ex)
            {
                CaptureBrowserLogs();
                var pageSource = Driver?.PageSource?.Substring(0, Math.Min(1000, Driver.PageSource.Length)) ?? "N/A";
                _logger.LogError($"Unexpected error during form filling at URL: {Driver?.Url ?? "N/A"}, Error: {ex.Message}, Page source: {pageSource}");

                try
                {
                    var handled = await DetectAndHandleType2Failure(data, new Dictionary<string, object?>());
                    if (handled)
                    {
                        _logger.LogWarning("Handled as Type 2 EIN failure during form fill. Skipping exception raise.");
                        return;
                    }
                }
                catch (Exception err)
                {
                    _logger.LogError($"Type 2 handler failed while processing EIN failure page: {err.Message}");
                }

                throw new AutomationError("Unexpected form filling error", ex.Message);
            }
        }

        public override async Task<(bool Success, string? Message, string? AzureBlobUrl)> RunAutomation(CaseData? data, Dictionary<string, object> jsonData)
        {
            string? einNumber = string.Empty;
            string? pdfAzureUrl = null;
            bool success = false;

            try
            {
                await _salesforceClient.InitializeSalesforceAuthAsync();

                var missingFields = data?.GetType()
                    .GetProperties()
                    .Where(p => p.GetValue(data) == null && p.Name != "RecordId")
                    .Select(p => p.Name)
                    .ToList() ?? new List<string>();
                if (missingFields.Any())
                {
                    _logger.LogInformation($"Missing fields detected (using defaults): {string.Join(", ", missingFields)}");
                    jsonData["missing_fields"] = missingFields;
                }

                InitializeDriver();

                if (string.IsNullOrWhiteSpace(data?.EntityType))
                {
                    throw new ArgumentNullException(nameof(data.EntityType), "EntityType is required");
                }
                if (data?.EntityType == "Trusteeship")
                {
                    await HandleTrusteeshipEntity(data);
                }
                else
                {
                    await NavigateAndFillForm(data, jsonData.ToDictionary(kvp => kvp.Key, kvp => (object?)kvp.Value));
                }

                // _______________________________________________final submit deployment ________________________________

                // // 5. Continue to EIN Letter
                // if (!ClickButton(By.XPath("//input[@type='submit' and @value='Submit']"), 
                //         "Final Continue before EIN download"))
                //     {
                //         throw new Exception("Failed to click final Continue button before EIN");
                //     }


                // (einNumber, pdfAzureUrl, success) = await FinalSubmit(data, jsonData, CancellationToken.None);
                

                 // Type "yes" to click final submit button____________________________local testing_____________________


                Console.WriteLine("Type 'yes' to continue to the EIN letter step:");
                string? input = Console.ReadLine();


                if (input?.Trim().ToLower() == "yes")
                {
                    if (!ClickButton(By.XPath("//input[@type='submit' and @value='Submit']"),
                        "Final Continue before EIN download"))
                    {
                        throw new Exception("Failed to click final Continue button before EIN");
                    }
                }
                else
                {
                    throw new Exception("User did not confirm with 'yes'. Aborting EIN letter step.");
                }
                
                // Type "yes" to download the EIN Letter

                Console.WriteLine("Type 'yes' to proceed with final EIN submission:");
                input = Console.ReadLine(); 

                if (input?.Trim().ToLower() == "yes")
                {
                    (einNumber, pdfAzureUrl, success) = await FinalSubmit(data, jsonData, CancellationToken.None);
                }
                else
                {
                    throw new Exception("User did not confirm with 'yes'. Aborting FinalSubmit.");
                }

                if (success && !string.IsNullOrEmpty(data?.RecordId) && !string.IsNullOrEmpty(einNumber))
                {
                    await _salesforceClient.NotifySalesforceSuccessAsync(data.RecordId!, einNumber);
                }

                return (success, einNumber, pdfAzureUrl);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Automation failed");

                string errorMsg = string.Empty;
                if (Driver != null)
                    errorMsg = _errorMessageExtractionService.ExtractErrorMessage(Driver);
                if (string.IsNullOrWhiteSpace(errorMsg))
                    errorMsg = ex.Message ?? "Unknown failure";
                if (jsonData != null)
                    jsonData["error_message"] = errorMsg;

                try
                {
                    var (failureBlobUrl, failureSuccess) = await CaptureFailurePageAsPdf(data, CancellationToken.None);
                    if (failureSuccess)
                    {
                        if (!string.IsNullOrEmpty(data?.RecordId))
                        {
                            await _salesforceClient.NotifySalesforceErrorCodeAsync(data.RecordId!, "500", "fail", Driver);
                        }
                    }
                    // Always save JSON with error message
                    if (jsonData != null)
                        await _blobStorageService.SaveJsonDataSync(jsonData.ToDictionary(kvp => kvp.Key, kvp => kvp.Value ?? new object()));
                }
                catch (Exception pdfError)
                {
                    _logger.LogWarning($"Failed to capture or upload failure PDF/JSON: {pdfError.Message}");
                }

                return (false, null, null);
            }
            finally
            {
                try
                {
                    var recordId = data?.RecordId ?? "unknown";
                    var logPath = DriverLogPath ?? string.Empty;
                    var logUrl = await _blobStorageService.UploadLogToBlob(recordId, logPath);
                    if (!string.IsNullOrEmpty(logUrl))
                    {
                        _logger.LogInformation($"Uploaded Chrome log to: {logUrl}");
                    }
                }
                catch (Exception logError)
                {
                    _logger.LogWarning($"Failed to upload Chrome logs: {logError.Message}");
                }

                // BROWSER KEPT OPEN FOR DEBUGGING - Cleanup commented out
                // Cleanup();
                _logger.LogInformation($"Browser instance kept open for debugging - Record ID: {data?.RecordId ?? "unknown"}");
            }
        }

private async Task<(string? EinNumber, string? PdfAzureUrl, bool Success)> FinalSubmit(CaseData? data, Dictionary<string, object>? jsonData, CancellationToken cancellationToken)
{
    string? einNumber = null;
    string? pdfAzureUrl = null;

    try
    {
        if (Driver == null)
        {
            _logger.LogError("Driver is null");
            return (null, null, false);
        }

        // Try to extract EIN
        try
        {
            var einElement = WaitHelper.WaitUntilExists(Driver, By.CssSelector("td[align='left'] > b"), 10);
            var einText = einElement?.Text?.Trim();

            if (!string.IsNullOrEmpty(einText) && Regex.IsMatch(einText, @"^\d{2}-\d{7}$"))
            {
                einNumber = einText;
            }
        }
        catch (Exception)
        {
            _logger.LogWarning("Primary EIN extraction failed. Attempting fallback with HtmlAgilityPack.");
            var doc = new HtmlDocument();
            doc.LoadHtml(Driver.PageSource);

            var einNode = doc.DocumentNode.SelectSingleNode("//td/b[contains(text(), '-')]");
            if (einNode != null)
            {
                var einText = einNode.InnerText.Trim();
                if (Regex.IsMatch(einText, @"^\d{2}-\d{7}$"))
                {
                    einNumber = einText;
                    _logger.LogInformation("Extracted EIN via fallback: {EinNumber}", einNumber);
                }
            }
        }

        if (!string.IsNullOrEmpty(einNumber) && jsonData != null)
        {
            jsonData["einNumber"] = einNumber;
        }

        // Handle failure page
        if (string.IsNullOrEmpty(einNumber))
        {
            string pageText = Driver?.PageSource?.ToLower() ?? string.Empty;

            if (pageText.Contains("we are unable to provide you with an ein"))
            {
                string referenceNumber = null;

                // Cache page source and HTML document for reuse across all methods
                var pageSource = Driver?.PageSource ?? string.Empty;
                var htmlDoc = new HtmlDocument();
                htmlDoc.LoadHtml(pageSource);
                _logger.LogInformation("Cached page source ({PageSize} chars) and HTML document for optimized extraction", pageSource.Length);

                // Use CancellationTokenSource for early termination
                using var cts = new CancellationTokenSource();
                var extractionTasks = new List<Task<(string? ReferenceNumber, string MethodName)>>();

                // Method 1: Selenium element search (fast)
                extractionTasks.Add(Task.Run(async () =>
                {
                    try
                    {
                        if (cts.Token.IsCancellationRequested) return (null, "Method1_Selenium");
                        
                        var refElement = WaitHelper.WaitUntilExists(Driver, By.XPath("//p[contains(text(), 'reference number')]"), 3); // Reduced timeout
                        if (refElement != null)
                        {
                            var refText = refElement.Text;
                            var refMatch = Regex.Match(refText, @"reference number\s+(\d+)", RegexOptions.IgnoreCase);
                            if (refMatch.Success)
                            {
                                return (refMatch.Groups[1].Value, "Method1_Selenium");
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("Method1_Selenium failed: {Message}", ex.Message);
                    }
                    return (null, "Method1_Selenium");
                }, cts.Token));

                // Method 2: Bold tags search (fast)
                extractionTasks.Add(Task.Run(() =>
                {
                    try
                    {
                        if (cts.Token.IsCancellationRequested) return (null, "Method2_BoldTags");
                        
                        var boldElements = Driver?.FindElements(By.XPath("//p[contains(text(), 'reference number')]//b"));
                        if (boldElements != null && boldElements.Count > 0)
                        {
                            foreach (var boldElement in boldElements)
                            {
                                var boldText = boldElement.Text?.Trim();
                                if (!string.IsNullOrEmpty(boldText) && Regex.IsMatch(boldText, @"^\d+$"))
                                {
                                    return (boldText, "Method2_BoldTags");
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("Method2_BoldTags failed: {Message}", ex.Message);
                    }
                    return (null, "Method2_BoldTags");
                }, cts.Token));

                // Method 3: Regex patterns on cached page source (fast)
                extractionTasks.Add(Task.Run(() =>
                {
                    try
                    {
                        if (cts.Token.IsCancellationRequested) return (null, "Method3_RegexPatterns");
                        
                        var patterns = new[]
                        {
                            @"reference number\s+(\d+)",
                            @"reference number[:\s]*(\d+)",
                            @"mention reference number\s+(\d+)",
                            @"reference number\s*<[^>]*>(\d+)<[^>]*>",
                            @"reference number[^0-9]*(\d+)",
                            @"(\d+)[^0-9]*reference number",
                            @"reference[^0-9]*number[^0-9]*(\d+)"
                        };

                        foreach (var pattern in patterns)
                        {
                            if (cts.Token.IsCancellationRequested) break;
                            var match = Regex.Match(pageSource, pattern, RegexOptions.IgnoreCase);
                            if (match.Success)
                            {
                                return (match.Groups[1].Value, "Method3_RegexPatterns");
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("Method3_RegexPatterns failed: {Message}", ex.Message);
                    }
                    return (null, "Method3_RegexPatterns");
                }, cts.Token));

                // Method 4: JavaScript extraction (medium speed)
                extractionTasks.Add(Task.Run(() =>
                {
                    try
                    {
                        if (cts.Token.IsCancellationRequested) return (null, "Method4_JavaScript");
                        
                        var jsExecutor = (IJavaScriptExecutor?)Driver;
                        var script = @"
                            function findReferenceNumberByPattern() {
                                var patterns = [
                                    /reference number\s+(\d+)/i,
                                    /reference number[:\s]*(\d+)/i,
                                    /mention reference number\s+(\d+)/i,
                                    /reference number[^0-9]*(\d+)/i,
                                    /(\d+)[^0-9]*reference number/i,
                                    /reference[^0-9]*number[^0-9]*(\d+)/i
                                ];
                                
                                var allText = document.body.textContent || document.body.innerText || '';
                                
                                for (var i = 0; i < patterns.length; i++) {
                                    var match = allText.match(patterns[i]);
                                    if (match) {
                                        return match[1];
                                    }
                                }
                                
                                return null;
                            }
                            return findReferenceNumberByPattern();
                        ";

                        var result = jsExecutor?.ExecuteScript(script)?.ToString();
                        if (!string.IsNullOrEmpty(result))
                        {
                            return (result, "Method4_JavaScript");
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("Method4_JavaScript failed: {Message}", ex.Message);
                    }
                    return (null, "Method4_JavaScript");
                }, cts.Token));

                // Method 5: HtmlAgilityPack with cached document (optimized)
                extractionTasks.Add(Task.Run(() =>
                {
                    try
                    {
                        if (cts.Token.IsCancellationRequested) return (null, "Method5_HtmlAgilityPack");
                        
                        // Use cached HTML document instead of parsing again
                        var textNodes = htmlDoc.DocumentNode.SelectNodes("//text()[contains(., 'reference number')]");
                        if (textNodes != null)
                        {
                            foreach (var node in textNodes)
                            {
                                if (cts.Token.IsCancellationRequested) break;
                                var nodeText = node.InnerText;
                                var patterns = new[]
                                {
                                    @"reference number\s+(\d+)",
                                    @"reference number[:\s]*(\d+)",
                                    @"mention reference number\s+(\d+)"
                                };

                                foreach (var pattern in patterns)
                                {
                                    var match = Regex.Match(nodeText, pattern, RegexOptions.IgnoreCase);
                                    if (match.Success)
                                    {
                                        return (match.Groups[1].Value, "Method5_HtmlAgilityPack");
                                    }
                                }
                            }
                        }

                        // Also check bold elements using cached document
                        var boldNodes = htmlDoc.DocumentNode.SelectNodes("//b[ancestor::*[contains(text(), 'reference number')]]");
                        if (boldNodes != null)
                        {
                            foreach (var boldNode in boldNodes)
                            {
                                if (cts.Token.IsCancellationRequested) break;
                                var boldText = boldNode.InnerText?.Trim();
                                if (!string.IsNullOrEmpty(boldText) && Regex.IsMatch(boldText, @"^\d+$"))
                                {
                                    return (boldText, "Method5_HtmlAgilityPack");
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("Method5_HtmlAgilityPack failed: {Message}", ex.Message);
                    }
                    return (null, "Method5_HtmlAgilityPack");
                }, cts.Token));

                // Method 6: Reduced XPath search (only most common selectors)
                extractionTasks.Add(Task.Run(() =>
                {
                    try
                    {
                        if (cts.Token.IsCancellationRequested) return (null, "Method6_ReducedXPath");
                        
                        // Reduced from 16 to 5 most effective selectors
                        var xpathSelectors = new[]
                        {
                            "//p[contains(text(), 'reference number')]",
                            "//div[contains(text(), 'reference number')]",
                            "//*[contains(@class, 'error') and contains(text(), 'reference number')]",
                            "//*[contains(@class, 'message') and contains(text(), 'reference number')]",
                            "//b[ancestor::*[contains(text(), 'reference number')]]"
                        };

                        foreach (var selector in xpathSelectors)
                        {
                            if (cts.Token.IsCancellationRequested) break;
                            try
                            {
                                var elements = Driver?.FindElements(By.XPath(selector));
                                if (elements != null && elements.Count > 0)
                                {
                                    foreach (var element in elements)
                                    {
                                        var elementText = element.Text;
                                        var match = Regex.Match(elementText, @"reference number\s+(\d+)", RegexOptions.IgnoreCase);
                                        if (match.Success)
                                        {
                                            return (match.Groups[1].Value, "Method6_ReducedXPath");
                                        }
                                    }
                                }
                            }
                            catch (Exception selectorEx)
                            {
                                _logger.LogDebug("XPath selector {Selector} failed: {Message}", selector, selectorEx.Message);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("Method6_ReducedXPath failed: {Message}", ex.Message);
                    }
                    return (null, "Method6_ReducedXPath");
                }, cts.Token));

                // Wait for first successful result with timeout
                var timeoutTask = Task.Delay(20000, cts.Token); // 20-second overall timeout
                var completedTask = await Task.WhenAny(extractionTasks.Concat(new[] { timeoutTask }));

                string? referenceNumber = null;
                string? successfulMethod = null;

                if (completedTask == timeoutTask)
                {
                    _logger.LogWarning("Reference number extraction timed out after 20 seconds");
                    cts.Cancel(); // Cancel remaining tasks
                }
                else
                {
                    // Check if any task completed successfully
                    foreach (var task in extractionTasks.Where(t => t.IsCompletedSuccessfully))
                    {
                        var result = await task;
                        if (!string.IsNullOrEmpty(result.ReferenceNumber))
                        {
                            referenceNumber = result.ReferenceNumber;
                            successfulMethod = result.MethodName;
                            _logger.LogInformation(" Reference number extracted via {Method}: {ReferenceNumber}", successfulMethod, referenceNumber);
                            cts.Cancel(); // Cancel remaining tasks for early termination
                            break;
                        }
                    }

                    // If no immediate success, wait a bit longer for remaining tasks
                    if (string.IsNullOrEmpty(referenceNumber))
                    {
                        try
                        {
                            await Task.WhenAll(extractionTasks);
                            
                            // Check all completed tasks for any successful result
                            foreach (var task in extractionTasks.Where(t => t.IsCompletedSuccessfully))
                            {
                                var result = await task;
                                if (!string.IsNullOrEmpty(result.ReferenceNumber))
                                {
                                    referenceNumber = result.ReferenceNumber;
                                    successfulMethod = result.MethodName;
                                    _logger.LogInformation(" Reference number extracted via {Method}: {ReferenceNumber}", successfulMethod, referenceNumber);
                                    break;
                                }
                            }
                        }
                        catch (OperationCanceledException)
                        {
                            _logger.LogDebug("Some extraction tasks were cancelled due to early termination");
                        }
                    }
                }

                if (string.IsNullOrEmpty(referenceNumber))
                {
                    _logger.LogWarning("All parallel reference number extraction methods failed");
                }



                // If parallel methods failed, try one final fallback method
                if (string.IsNullOrEmpty(referenceNumber))
                {
                    _logger.LogWarning("All parallel reference number extraction methods failed. Attempting final fallback search.");

                    // Simple final fallback - just search for any number in the cached page source
                    try
                    {

                        // Simple fallback - search for any reasonable number in the cached page source
                        var allNumbers = Regex.Matches(pageSource, @"\b\d{6,10}\b"); // Look for 6-10 digit numbers
                        if (allNumbers.Count > 0)
                        {
                            // Take the first reasonable number that might be a reference number
                            foreach (Match match in allNumbers)
                            {
                                var number = match.Value;
                                // Skip years and common non-reference patterns
                                if (number.Length >= 6 && !number.StartsWith("20") && !number.StartsWith("19"))
                                {
                                    referenceNumber = number;
                                    _logger.LogInformation("Extracted potential reference number via final fallback: {ReferenceNumber}", referenceNumber);
                                    break;
                                }
                            }
                        }

                    }
                    catch (Exception ex)
                    {
                        _logger.LogError("Final fallback reference number extraction failed: {Message}", ex.Message);
                    }
                }
                            if (boldNodes != null)
                            {
                                foreach (var boldNode in boldNodes)
                                {
                                    var boldText = boldNode.InnerText?.Trim();
                                    if (!string.IsNullOrEmpty(boldText) && Regex.IsMatch(boldText, @"^\d+$"))
                                    {
                                        // Check if this bold element is near "reference number" text
                                        var parentText = boldNode.ParentNode?.InnerText ?? "";
                                        var ancestorText = GetAncestorText(boldNode, 3); // Check up to 3 levels up
                                        
                                        if (parentText.ToLower().Contains("reference number") || 
                                            ancestorText.ToLower().Contains("reference number"))
                                        {
                                            referenceNumber = boldText;
                                            _logger.LogInformation("Extracted IRS Reference Number from bold near reference text: {ReferenceNumber}", referenceNumber);
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        // Method 4c: Search for any paragraph containing "reference number" and extract the number
                        if (string.IsNullOrEmpty(referenceNumber))
                        {
                            var paragraphNodes = doc.DocumentNode.SelectNodes("//p[contains(., 'reference number')]");
                            if (paragraphNodes != null)
                            {
                                foreach (var paragraph in paragraphNodes)
                                {
                                    var paragraphText = paragraph.InnerText;
                                    var patterns = new[]
                                    {
                                        @"reference number\s+(\d+)",
                                        @"reference number[:\s]*(\d+)",
                                        @"mention reference number\s+(\d+)",
                                        @"reference number[^0-9]*(\d+)",
                                        @"(\d+)[^0-9]*reference number"
                                    };

                                    foreach (var pattern in patterns)
                                    {
                                        var match = Regex.Match(paragraphText, pattern, RegexOptions.IgnoreCase);
                                        if (match.Success)
                                        {
                                            referenceNumber = match.Groups[1].Value;
                                            _logger.LogInformation("Extracted IRS Reference Number from paragraph pattern '{Pattern}': {ReferenceNumber}", pattern, referenceNumber);
                                            break;
                                        }
                                    }
                                    if (!string.IsNullOrEmpty(referenceNumber)) break;
                                }
                            }
                        }

                        // Method 4d: Search for any div containing "reference number"
                        if (string.IsNullOrEmpty(referenceNumber))
                        {
                            var divNodes = doc.DocumentNode.SelectNodes("//div[contains(., 'reference number')]");
                            if (divNodes != null)
                            {
                                foreach (var div in divNodes)
                                {
                                    var divText = div.InnerText;
                                    var patterns = new[]
                                    {
                                        @"reference number\s+(\d+)",
                                        @"reference number[:\s]*(\d+)",
                                        @"mention reference number\s+(\d+)",
                                        @"reference number[^0-9]*(\d+)",
                                        @"(\d+)[^0-9]*reference number"
                                    };

                                    foreach (var pattern in patterns)
                                    {
                                        var match = Regex.Match(divText, pattern, RegexOptions.IgnoreCase);
                                        if (match.Success)
                                        {
                                            referenceNumber = match.Groups[1].Value;
                                            _logger.LogInformation("Extracted IRS Reference Number from div pattern '{Pattern}': {ReferenceNumber}", pattern, referenceNumber);
                                            break;
                                        }
                                    }
                                    if (!string.IsNullOrEmpty(referenceNumber)) break;
                                }
                            }
                        }

                        // Method 4e: Last resort - search entire document for any number near "reference number"
                        if (string.IsNullOrEmpty(referenceNumber))
                        {
                            var allText = doc.DocumentNode.InnerText;
                            var patterns = new[]
                            {
                                @"reference number\s+(\d+)",
                                @"reference number[:\s]*(\d+)",
                                @"mention reference number\s+(\d+)",
                                @"reference number[^0-9]*(\d+)",
                                @"(\d+)[^0-9]*reference number",
                                @"reference[^0-9]*number[^0-9]*(\d+)"
                            };

                            foreach (var pattern in patterns)
                            {
                                var match = Regex.Match(allText, pattern, RegexOptions.IgnoreCase);
                                if (match.Success)
                                {
                                    referenceNumber = match.Groups[1].Value;
                                    _logger.LogInformation("Extracted IRS Reference Number via document-wide pattern '{Pattern}': {ReferenceNumber}", pattern, referenceNumber);
                                    break;
                                }
                            }
                        }

                        // Method 4f: Search for any element with specific CSS classes or IDs that might contain reference numbers
                        if (string.IsNullOrEmpty(referenceNumber))
                        {
                            var cssSelectors = new[]
                            {
                                "//*[contains(@class, 'reference')]",
                                "//*[contains(@class, 'number')]",
                                "//*[contains(@id, 'reference')]",
                                "//*[contains(@id, 'number')]",
                                "//*[contains(@class, 'error')]",
                                "//*[contains(@class, 'message')]",
                                "//*[contains(@class, 'notification')]"
                            };

                            foreach (var selector in cssSelectors)
                            {
                                try
                                {
                                    var elements = doc.DocumentNode.SelectNodes(selector);
                                    if (elements != null)
                                    {
                                        foreach (var element in elements)
                                        {
                                            var elementText = element.InnerText;
                                            if (elementText.ToLower().Contains("reference number"))
                                            {
                                                var patterns = new[]
                                                {
                                                    @"reference number\s+(\d+)",
                                                    @"reference number[:\s]*(\d+)",
                                                    @"mention reference number\s+(\d+)",
                                                    @"reference number[^0-9]*(\d+)",
                                                    @"(\d+)[^0-9]*reference number"
                                                };

                                                foreach (var pattern in patterns)
                                                {
                                                    var match = Regex.Match(elementText, pattern, RegexOptions.IgnoreCase);
                                                    if (match.Success)
                                                    {
                                                        referenceNumber = match.Groups[1].Value;
                                                        _logger.LogInformation("Extracted IRS Reference Number via CSS selector '{Selector}' pattern '{Pattern}': {ReferenceNumber}", selector, pattern, referenceNumber);
                                                        break;
                                                    }
                                                }
                                                if (!string.IsNullOrEmpty(referenceNumber)) break;
                                            }
                                        }
                                    }
                                }
                                catch (Exception ex)
                                {
                                    _logger.LogDebug("CSS selector {Selector} failed: {Message}", selector, ex.Message);
                                }
                                if (!string.IsNullOrEmpty(referenceNumber)) break;
                            }
                        }

                        // Method 4g: Search for any span or div containing numbers near "reference number" text
                        if (string.IsNullOrEmpty(referenceNumber))
                        {
                            var spanNodes = doc.DocumentNode.SelectNodes("//span");
                            if (spanNodes != null)
                            {
                                foreach (var span in spanNodes)
                                {
                                    var spanText = span.InnerText?.Trim();
                                    if (!string.IsNullOrEmpty(spanText) && Regex.IsMatch(spanText, @"^\d+$"))
                                    {
                                        // Check if this span is near "reference number" text
                                        var parentText = span.ParentNode?.InnerText ?? "";
                                        var ancestorText = GetAncestorText(span, 5); // Check up to 5 levels up
                                        
                                        if (parentText.ToLower().Contains("reference number") || 
                                            ancestorText.ToLower().Contains("reference number"))
                                        {
                                            referenceNumber = spanText;
                                            _logger.LogInformation("Extracted IRS Reference Number from span near reference text: {ReferenceNumber}", referenceNumber);
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        // Method 4h: Search for any table containing "reference number"
                        if (string.IsNullOrEmpty(referenceNumber))
                        {
                            var tableNodes = doc.DocumentNode.SelectNodes("//table");
                            if (tableNodes != null)
                            {
                                foreach (var table in tableNodes)
                                {
                                    var tableText = table.InnerText;
                                    if (tableText.ToLower().Contains("reference number"))
                                    {
                                        var patterns = new[]
                                        {
                                            @"reference number\s+(\d+)",
                                            @"reference number[:\s]*(\d+)",
                                            @"mention reference number\s+(\d+)",
                                            @"reference number[^0-9]*(\d+)",
                                            @"(\d+)[^0-9]*reference number"
                                        };

                                        foreach (var pattern in patterns)
                                        {
                                            var match = Regex.Match(tableText, pattern, RegexOptions.IgnoreCase);
                                            if (match.Success)
                                            {
                                                referenceNumber = match.Groups[1].Value;
                                                _logger.LogInformation("Extracted IRS Reference Number from table pattern '{Pattern}': {ReferenceNumber}", pattern, referenceNumber);
                                                break;
                                            }
                                        }
                                        if (!string.IsNullOrEmpty(referenceNumber)) break;
                                    }
                                }
                            }
                        }

                        // Method 4i: Search for any list item containing "reference number"
                        if (string.IsNullOrEmpty(referenceNumber))
                        {
                            var listNodes = doc.DocumentNode.SelectNodes("//li");
                            if (listNodes != null)
                            {
                                foreach (var listItem in listNodes)
                                {
                                    var listText = listItem.InnerText;
                                    if (listText.ToLower().Contains("reference number"))
                                    {
                                        var patterns = new[]
                                        {
                                            @"reference number\s+(\d+)",
                                            @"reference number[:\s]*(\d+)",
                                            @"mention reference number\s+(\d+)",
                                            @"reference number[^0-9]*(\d+)",
                                            @"(\d+)[^0-9]*reference number"
                                        };

                                        foreach (var pattern in patterns)
                                        {
                                            var match = Regex.Match(listText, pattern, RegexOptions.IgnoreCase);
                                            if (match.Success)
                                            {
                                                referenceNumber = match.Groups[1].Value;
                                                _logger.LogInformation("Extracted IRS Reference Number from list item pattern '{Pattern}': {ReferenceNumber}", pattern, referenceNumber);
                                                break;
                                            }
                                        }
                                        if (!string.IsNullOrEmpty(referenceNumber)) break;
                                    }
                                }
                            }
                        }

                        // Method 4j: Search for any heading containing "reference number"
                        if (string.IsNullOrEmpty(referenceNumber))
                        {
                            var headingNodes = doc.DocumentNode.SelectNodes("//h1|//h2|//h3|//h4|//h5|//h6");
                            if (headingNodes != null)
                            {
                                foreach (var heading in headingNodes)
                                {
                                    var headingText = heading.InnerText;
                                    if (headingText.ToLower().Contains("reference number"))
                                    {
                                        var patterns = new[]
                                        {
                                            @"reference number\s+(\d+)",
                                            @"reference number[:\s]*(\d+)",
                                            @"mention reference number\s+(\d+)",
                                            @"reference number[^0-9]*(\d+)",
                                            @"(\d+)[^0-9]*reference number"
                                        };

                                        foreach (var pattern in patterns)
                                        {
                                            var match = Regex.Match(headingText, pattern, RegexOptions.IgnoreCase);
                                            if (match.Success)
                                            {
                                                referenceNumber = match.Groups[1].Value;
                                                _logger.LogInformation("Extracted IRS Reference Number from heading pattern '{Pattern}': {ReferenceNumber}", pattern, referenceNumber);
                                                break;
                                            }
                                        }
                                        if (!string.IsNullOrEmpty(referenceNumber)) break;
                                    }
                                }
                            }
                        }

                        // Method 4k: Search for any element with data attributes containing "reference number"
                        if (string.IsNullOrEmpty(referenceNumber))
                        {
                            var dataAttributeNodes = doc.DocumentNode.SelectNodes("//*[@data-*]");
                            if (dataAttributeNodes != null)
                            {
                                foreach (var element in dataAttributeNodes)
                                {
                                    var elementText = element.InnerText;
                                    if (elementText.ToLower().Contains("reference number"))
                                    {
                                        var patterns = new[]
                                        {
                                            @"reference number\s+(\d+)",
                                            @"reference number[:\s]*(\d+)",
                                            @"mention reference number\s+(\d+)",
                                            @"reference number[^0-9]*(\d+)",
                                            @"(\d+)[^0-9]*reference number"
                                        };

                                        foreach (var pattern in patterns)
                                        {
                                            var match = Regex.Match(elementText, pattern, RegexOptions.IgnoreCase);
                                            if (match.Success)
                                            {
                                                referenceNumber = match.Groups[1].Value;
                                                _logger.LogInformation("Extracted IRS Reference Number from data attribute element pattern '{Pattern}': {ReferenceNumber}", pattern, referenceNumber);
                                                break;
                                            }
                                        }
                                        if (!string.IsNullOrEmpty(referenceNumber)) break;
                                    }
                                }
                            }
                        }

                        // Method 4l: Search for any element with aria-label containing "reference number"
                        if (string.IsNullOrEmpty(referenceNumber))
                        {
                            var ariaLabelNodes = doc.DocumentNode.SelectNodes("//*[@aria-label]");
                            if (ariaLabelNodes != null)
                            {
                                foreach (var element in ariaLabelNodes)
                                {
                                    var ariaLabel = element.GetAttributeValue("aria-label", "");
                                    var elementText = element.InnerText;
                                    
                                    if ((ariaLabel.ToLower().Contains("reference number") || 
                                         elementText.ToLower().Contains("reference number")))
                                    {
                                        var patterns = new[]
                                        {
                                            @"reference number\s+(\d+)",
                                            @"reference number[:\s]*(\d+)",
                                            @"mention reference number\s+(\d+)",
                                            @"reference number[^0-9]*(\d+)",
                                            @"(\d+)[^0-9]*reference number"
                                        };

                                        foreach (var pattern in patterns)
                                        {
                                            var match = Regex.Match(elementText, pattern, RegexOptions.IgnoreCase);
                                            if (match.Success)
                                            {
                                                referenceNumber = match.Groups[1].Value;
                                                _logger.LogInformation("Extracted IRS Reference Number from aria-label element pattern '{Pattern}': {ReferenceNumber}", pattern, referenceNumber);
                                                break;
                                            }
                                        }
                                        if (!string.IsNullOrEmpty(referenceNumber)) break;
                                    }
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError("Robust text-based parsing of reference number failed: {Message}", ex.Message);
                    }
                }

                // Method 5: Ultimate fallback - Search for any number that appears to be a reference number
                if (string.IsNullOrEmpty(referenceNumber))
                {
                    _logger.LogWarning("All standard reference number extraction methods failed. Attempting ultimate fallback search.");
                    
                    try
                    {
                        // Search for any number that might be a reference number based on context
                        var jsExecutor = (IJavaScriptExecutor?)Driver;
                        var script = @"
                            function findAnyReferenceNumber() {
                                // Look for any number in error messages or notifications
                                var errorElements = document.querySelectorAll('.error, .message, .notification, [class*=""error""], [class*=""message""], [class*=""notification""]');
                                for (var i = 0; i < errorElements.length; i++) {
                                    var text = errorElements[i].textContent || errorElements[i].innerText || '';
                                    var numbers = text.match(/\d+/g);
                                    if (numbers && numbers.length > 0) {
                                        // Return the first number found in error context
                                        return numbers[0];
                                    }
                                }
                                
                                // Look for any number in paragraphs that contain error-related text
                                var paragraphs = document.querySelectorAll('p');
                                for (var i = 0; i < paragraphs.length; i++) {
                                    var text = paragraphs[i].textContent || paragraphs[i].innerText || '';
                                    var lowerText = text.toLowerCase();
                                    if (lowerText.includes('unable') || lowerText.includes('error') || 
                                        lowerText.includes('problem') || lowerText.includes('issue') ||
                                        lowerText.includes('contact') || lowerText.includes('call')) {
                                        var numbers = text.match(/\d+/g);
                                        if (numbers && numbers.length > 0) {
                                            return numbers[0];
                                        }
                                    }
                                }
                                
                                // Look for any number in the entire page that might be a reference
                                var allText = document.body.textContent || document.body.innerText || '';
                                var allNumbers = allText.match(/\d+/g);
                                if (allNumbers && allNumbers.length > 0) {
                                    // Filter out common non-reference numbers (years, dates, etc.)
                                    for (var i = 0; i < allNumbers.length; i++) {
                                        var num = allNumbers[i];
                                        // Skip years (4 digits starting with 19 or 20)
                                        if (num.length === 4 && (num.startsWith('19') || num.startsWith('20'))) {
                                            continue;
                                        }
                                        // Skip very short numbers (likely not reference numbers)
                                        if (num.length < 3) {
                                            continue;
                                        }
                                        // Skip very long numbers (likely not reference numbers)
                                        if (num.length > 10) {
                                            continue;
                                        }
                                        return num;
                                    }
                                }
                                
                                return null;
                            }
                            return findAnyReferenceNumber();
                        ";

                        var result = jsExecutor?.ExecuteScript(script)?.ToString();
                        if (!string.IsNullOrEmpty(result))
                        {
                            referenceNumber = result;
                            _logger.LogInformation("Extracted IRS Reference Number via ultimate fallback: {ReferenceNumber}", referenceNumber);
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError("Ultimate fallback reference number extraction failed: {Message}", ex.Message);
                    }
                }

                if (!string.IsNullOrEmpty(referenceNumber) && jsonData != null)
                {
                    jsonData["irs_reference_number"] = referenceNumber;
                }

                await CaptureFailurePageAsPdf(data, cancellationToken);
                await _salesforceClient.NotifySalesforceErrorCodeAsync(data?.RecordId, referenceNumber ?? "fail", "fail", Driver);
                return (null, null, false);
            }
            else
            {
                await CaptureFailurePageAsPdf(data, cancellationToken);
                await _salesforceClient.NotifySalesforceErrorCodeAsync(data?.RecordId, "500", "fail", Driver);
                return (null, null, false);
            }
        }

        private async Task<(string? EinNumber, string? PdfAzureUrl, bool Success)> TryDownloadEinLetterPdfWithSelenium(string? einNumber, CaseData? data, Dictionary<string, object>? jsonData, CancellationToken cancellationToken)
        {
            string? pdfAzureUrl = null;
            
            try
            {
                _logger.LogInformation("Starting EIN Letter PDF capture for AKS deployment...");
                
                // Capture the EIN letter page as PDF using multiple enhanced capture methods
                var (blobUrl, success) = await CapturePageAsPdfEnhanced(data, cancellationToken);
                
                if (success && !string.IsNullOrEmpty(blobUrl))
                {
                    pdfAzureUrl = blobUrl;
                    
                    if (jsonData != null)
                    {
                        try
                        {
                            await _blobStorageService.SaveJsonDataSync(jsonData);
                            _logger.LogInformation("JSON data saved successfully");
                        }
                        catch (Exception jsonEx)
                        {
                            _logger.LogWarning("Failed to save JSON data: {Message}", jsonEx.Message);
                        }
                    }

                    try
                    {
                        await _salesforceClient.NotifyEinLetterToSalesforceAsync(data?.RecordId, pdfAzureUrl, data?.EntityName);
                        _logger.LogInformation("Salesforce EIN Letter notification sent successfully");
                    }
                    catch (Exception sfEx)
                    {
                        _logger.LogWarning("Failed to notify Salesforce about EIN Letter: {Message}", sfEx.Message);
                    }

                    try
                    {
                        await _salesforceClient.NotifySalesforceSuccessAsync(data?.RecordId, einNumber);
                        _logger.LogInformation("Salesforce success notification sent successfully");
                    }
                    catch (Exception sfEx)
                    {
                        _logger.LogWarning("Failed to notify Salesforce about success: {Message}", sfEx.Message);
                    }

                    _logger.LogInformation("EIN Letter PDF successfully captured and uploaded to Azure: {BlobUrl}", blobUrl);
                    return (einNumber, pdfAzureUrl, true);
                }
                else
                {
                    throw new Exception("PDF capture failed or returned empty content");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError("PDF capture failed: {Message}", ex.Message);

                // Try to save JSON data even on failure
                if (jsonData != null)
                {
                    try
                    {
                        await _blobStorageService.SaveJsonDataSync(jsonData);
                        _logger.LogInformation("JSON data saved despite PDF capture failure");
                    }
                    catch (Exception jsonEx)
                    {
                        _logger.LogWarning("Failed to save JSON data after PDF capture failure: {Message}", jsonEx.Message);
                    }
                }

                // Try to capture failure page
                try
                {
                    await CaptureFailurePageAsPdf(data, cancellationToken);
                    _logger.LogInformation("Failure page captured successfully");
                }
                catch (Exception captureEx)
                {
                    _logger.LogWarning("Failed to capture failure page: {Message}", captureEx.Message);
                }

                // Try to notify Salesforce about the failure
                try
                {
                    await _salesforceClient.NotifySalesforceErrorCodeAsync(data?.RecordId, einNumber, "fail", Driver);
                    _logger.LogInformation("Salesforce error notification sent successfully");
                }
                catch (Exception sfEx)
                {
                    _logger.LogWarning("Failed to notify Salesforce about error: {Message}", sfEx.Message);
                }

                return (einNumber, null, true);
            }
        }

        private async Task<byte[]?> TryDownloadEinLetterPdfWithSelenium(string? einNumber, CaseData? data, Dictionary<string, object>? jsonData, CancellationToken cancellationToken)
        {
            string? downloadDir = null;
            string? downloadsFolder = null;
            byte[]? firstSuccessfulPdf = null; // Track the first successful PDF to return
            var successfulMethods = new List<string>(); // Track which methods succeeded
            
            try
            {
                // Create a unique download directory for container deployment
                downloadDir = Path.Combine(Path.GetTempPath(), "ein_pdfs", DateTime.Now.Ticks.ToString());
                Directory.CreateDirectory(downloadDir);
                _logger.LogInformation("Created download directory: {DownloadDir}", downloadDir);

                // Also get the user's Downloads folder for local development
                downloadsFolder = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
                downloadsFolder = Path.Combine(downloadsFolder, "Downloads");
                _logger.LogInformation("Monitoring Downloads folder: {DownloadsFolder}", downloadsFolder);

                // Configure Chrome download preferences dynamically
                await ConfigureDownloadDirectory(downloadDir);

                // Wait for confirmation page to load and find the PDF link
                _logger.LogInformation("Waiting for confirmation page to load and PDF link to appear...");
                await Task.Delay(3000, cancellationToken); // Wait for page to fully load
                
                // Verify we're on the confirmation page
                var pageSource = Driver?.PageSource?.ToLower() ?? "";
                if (!pageSource.Contains("confirmation") && !pageSource.Contains("ein has been successfully assigned"))
                {
                    _logger.LogWarning("Not on confirmation page, waiting longer...");
                    await Task.Delay(5000, cancellationToken);
                }
                
                // Find and click the PDF link
                var pdfLinkElement = await FindPdfLinkElement();
                if (pdfLinkElement == null)
                {
                    _logger.LogWarning("PDF link not found initially, waiting longer and retrying...");
                    await Task.Delay(5000, cancellationToken); // Wait longer
                    pdfLinkElement = await FindPdfLinkElement();
                    
                    if (pdfLinkElement == null)
                    {
                        throw new Exception("PDF link element not found after all attempts");
                    }
                }
                
                _logger.LogInformation("Found PDF link element: {Href}", pdfLinkElement.GetAttribute("href"));
                _logger.LogInformation("PDF link onclick: {OnClick}", pdfLinkElement.GetAttribute("onclick"));
                _logger.LogInformation("PDF link text: {Text}", pdfLinkElement.Text);

                _logger.LogInformation("Starting comprehensive PDF download - ALL METHODS WILL BE ATTEMPTED");
                
                // Method 1: Try window-based PDF capture FIRST (open PDF in new tab and extract content)
                // This is prioritized because it ensures the PDF is actually opened and loaded before capture
                _logger.LogInformation("=== METHOD 1: Window-based PDF capture ===");
                try
                {
                    var pdfBytes = await TryWindowBasedPdfCapture(pdfLinkElement, cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation(" METHOD 1 SUCCESS: Window-based capture - {FileSize} bytes", pdfBytes.Length);
                        // Save this PDF with proper blob naming
                        await SavePdfWithMethodIdentifier(pdfBytes, "Method1_WindowBased", data, cancellationToken);
                        successfulMethods.Add("Method1_WindowBased");
                        if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 1 FAILED: Window-based capture returned null or empty");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 1 EXCEPTION: Window-based capture failed - {Message}", ex.Message);
                }

                // Method 2: Try direct download as fallback
                _logger.LogInformation("=== METHOD 2: Direct download ===");
                try
                {
                    var pdfBytes = await TryDirectDownload(pdfLinkElement, cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation(" METHOD 2 SUCCESS: Direct download - {FileSize} bytes", pdfBytes.Length);
                        // Save this PDF with proper blob naming
                        await SavePdfWithMethodIdentifier(pdfBytes, "Method2_DirectDownload", data, cancellationToken);
                        successfulMethods.Add("Method2_DirectDownload");
                        if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 2 FAILED: Direct download returned null or empty");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 2 EXCEPTION: Direct download failed - {Message}", ex.Message);
                }

                // Method 3: Try clicking the PDF link and capturing from current window
                _logger.LogInformation("=== METHOD 3: Click and capture from current window ===");
                try
                {
                    var pdfBytes = await TryClickAndCaptureFromCurrentWindow(pdfLinkElement, cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation(" METHOD 3 SUCCESS: Click and capture - {FileSize} bytes", pdfBytes.Length);
                        // Save this PDF with proper blob naming
                        await SavePdfWithMethodIdentifier(pdfBytes, "Method3_ClickCapture", data, cancellationToken);
                        successfulMethods.Add("Method3_ClickCapture");
                        if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 3 FAILED: Click and capture returned null or empty");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 3 EXCEPTION: Click and capture failed - {Message}", ex.Message);
                }

                // Method 4: Try Chrome DevTools PDF capture
                _logger.LogInformation("=== METHOD 4: Chrome DevTools PDF capture ===");
                try
                {
                    var pdfBytes = await TryChromeDevToolsPdfCapture(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation(" METHOD 4 SUCCESS: Chrome DevTools capture - {FileSize} bytes", pdfBytes.Length);
                        // Save this PDF with proper blob naming
                        await SavePdfWithMethodIdentifier(pdfBytes, "Method4_ChromeDevTools", data, cancellationToken);
                        successfulMethods.Add("Method4_ChromeDevTools");
                        if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 4 FAILED: Chrome DevTools capture returned null or empty");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 4 EXCEPTION: Chrome DevTools capture failed - {Message}", ex.Message);
                }

                // Method 5: Try ultimate fallback PDF download
                _logger.LogInformation("=== METHOD 5: Ultimate fallback PDF download ===");
                try
                {
                    var pdfBytes = await TryUltimateFallbackPdfDownload(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation(" METHOD 5 SUCCESS: Ultimate fallback - {FileSize} bytes", pdfBytes.Length);
                        // Save this PDF with proper blob naming
                        await SavePdfWithMethodIdentifier(pdfBytes, "Method5_UltimateFallback", data, cancellationToken);
                        successfulMethods.Add("Method5_UltimateFallback");
                        if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 5 FAILED: Ultimate fallback returned null or empty");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 5 EXCEPTION: Ultimate fallback failed - {Message}", ex.Message);
                }

                // Method 6: Click the PDF link first, then add delay and try multiple capture methods
                _logger.LogInformation("=== METHOD 6: Click PDF link with delay and multiple capture methods ===");
                try
                {
                    var clicked = await TryClickPdfLink(pdfLinkElement);
                    if (clicked)
                    {
                        _logger.LogInformation(" METHOD 6: Successfully clicked PDF link");
                        
                        // Add delay AFTER clicking the link to ensure PDF loads properly
                        _logger.LogInformation("Adding 10-second delay after clicking PDF link to ensure proper loading...");
                        await Task.Delay(10000, cancellationToken); // 10-second delay for PDF to load
                        
                        // Wait for PDF to be fully loaded by checking for PDF indicators
                        _logger.LogInformation("Waiting for PDF to be fully loaded...");
                        var maxWaitTime = 30000; // 30 seconds
                        var waitInterval = 2000; // 2 seconds
                        var totalWaited = 0;
                        
                        while (totalWaited < maxWaitTime && !cancellationToken.IsCancellationRequested)
                        {
                            var currentUrl = Driver?.Url ?? "";
                            var currentPageSource = Driver?.PageSource ?? "";
                            
                            // Check if we're on a PDF page
                            if (currentUrl.Contains(".pdf") || 
                                currentPageSource.Contains("PDF") || 
                                currentPageSource.Contains("application/pdf") ||
                                currentUrl.Contains("CP575"))
                            {
                                _logger.LogInformation("PDF appears to be loaded. Current URL: {Url}", currentUrl);
                                break;
                            }
                            
                            await Task.Delay(waitInterval, cancellationToken);
                            totalWaited += waitInterval;
                            _logger.LogDebug("Waited {TotalWaited}ms for PDF to load...", totalWaited);
                        }
                        
                        // Try multiple capture methods after clicking
                        _logger.LogInformation("Attempting to capture PDF after clicking link...");
                        
                        // Try Chrome DevTools capture after clicking
                        _logger.LogInformation("--- Method 6a: Chrome DevTools capture after clicking ---");
                        try
                        {
                            var pdfBytes = await TryChromeDevToolsPdfCapture(cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation(" METHOD 6a SUCCESS: Chrome DevTools capture after clicking - {FileSize} bytes", pdfBytes.Length);
                                await SavePdfWithMethodIdentifier(pdfBytes, "Method6a_ChromeDevToolsAfterClick", data, cancellationToken);
                                successfulMethods.Add("Method6a_ChromeDevToolsAfterClick");
                                if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                            }
                            else
                            {
                                _logger.LogWarning(" METHOD 6a FAILED: Chrome DevTools capture after clicking returned null or empty");
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogWarning(" METHOD 6a EXCEPTION: Chrome DevTools capture after clicking failed - {Message}", ex.Message);
                        }
                        
                        // Try ultimate fallback after clicking
                        _logger.LogInformation("--- Method 6b: Ultimate fallback after clicking ---");
                        try
                        {
                            var pdfBytes = await TryUltimateFallbackPdfDownload(cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation(" METHOD 6b SUCCESS: Ultimate fallback after clicking - {FileSize} bytes", pdfBytes.Length);
                                await SavePdfWithMethodIdentifier(pdfBytes, "Method6b_UltimateFallbackAfterClick", data, cancellationToken);
                                successfulMethods.Add("Method6b_UltimateFallbackAfterClick");
                                if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                            }
                            else
                            {
                                _logger.LogWarning(" METHOD 6b FAILED: Ultimate fallback after clicking returned null or empty");
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogWarning(" METHOD 6b EXCEPTION: Ultimate fallback after clicking failed - {Message}", ex.Message);
                        }
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 6 SETUP FAILED: Could not click PDF link");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 6 EXCEPTION: Click PDF link process failed - {Message}", ex.Message);
                }
                
                // Try to capture from any new tabs that might have opened (Method 6c)
                _logger.LogInformation("--- Method 6c: Checking for PDF in new tabs/windows ---");
                try
                {
                    var currentWindows = Driver?.WindowHandles.ToList() ?? new List<string>();
                    // Note: We can't compare with originalWindows here since it's not defined in this scope
                    // So we'll check all windows for PDF content
                    
                    foreach (var windowHandle in currentWindows)
                    {
                        try
                        {
                            Driver?.SwitchTo().Window(windowHandle);
                            await Task.Delay(3000, cancellationToken); // Wait for window to load
                            
                            var windowUrl = Driver?.Url ?? "";
                            _logger.LogInformation("Checking window: {Url}", windowUrl);
                            
                            // Try to capture PDF from this window (Method 6c1)
                            _logger.LogInformation("--- Method 6c1: Chrome DevTools capture from window ---");
                            try
                            {
                                var pdfBytes = await TryChromeDevToolsPdfCapture(cancellationToken);
                                if (pdfBytes != null && pdfBytes.Length > 0)
                                {
                                    _logger.LogInformation(" METHOD 6c1 SUCCESS: Captured PDF from window - {FileSize} bytes", pdfBytes.Length);
                                    await SavePdfWithMethodIdentifier(pdfBytes, "Method6c1_WindowChromeDevTools", data, cancellationToken);
                                    successfulMethods.Add("Method6c1_WindowChromeDevTools");
                                    if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                                }
                                else
                                {
                                    _logger.LogWarning(" METHOD 6c1 FAILED: Chrome DevTools capture from window returned null or empty");
                                }
                            }
                            catch (Exception ex)
                            {
                                _logger.LogWarning(" METHOD 6c1 EXCEPTION: Chrome DevTools capture from window failed - {Message}", ex.Message);
                            }
                            
                            // Try ultimate fallback on this window (Method 6c2)
                            _logger.LogInformation("--- Method 6c2: Ultimate fallback from window ---");
                            try
                            {
                                var pdfBytes = await TryUltimateFallbackPdfDownload(cancellationToken);
                                if (pdfBytes != null && pdfBytes.Length > 0)
                                {
                                    _logger.LogInformation(" METHOD 6c2 SUCCESS: Ultimate fallback succeeded on window - {FileSize} bytes", pdfBytes.Length);
                                    await SavePdfWithMethodIdentifier(pdfBytes, "Method6c2_WindowUltimateFallback", data, cancellationToken);
                                    successfulMethods.Add("Method6c2_WindowUltimateFallback");
                                    if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                                }
                                else
                                {
                                    _logger.LogWarning(" METHOD 6c2 FAILED: Ultimate fallback from window returned null or empty");
                                }
                            }
                            catch (Exception ex)
                            {
                                _logger.LogWarning(" METHOD 6c2 EXCEPTION: Ultimate fallback from window failed - {Message}", ex.Message);
                            }
                        }
                        catch (Exception windowEx)
                        {
                            _logger.LogDebug("Error checking window {Window}: {Message}", windowHandle, windowEx.Message);
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 6c EXCEPTION: Window checking process failed - {Message}", ex.Message);
                }

                // Method 7: Wait for download to complete in both directories with increased timeout
                _logger.LogInformation("=== METHOD 7: Wait for download to complete ===");
                try
                {
                    var downloadedFile = await WaitForDownloadCompleteMultiLocation(downloadDir, downloadsFolder, 120000, cancellationToken); // Increased timeout to 120 seconds
                    if (!string.IsNullOrEmpty(downloadedFile))
                    {
                        // Read and validate the downloaded PDF
                        var downloadedBytes = await File.ReadAllBytesAsync(downloadedFile, cancellationToken);
                        
                        if (IsValidPdf(downloadedBytes))
                        {
                            _logger.LogInformation(" METHOD 7 SUCCESS: Click-based download - {FilePath}, {FileSize} bytes", 
                                downloadedFile, downloadedBytes.Length);
                            await SavePdfWithMethodIdentifier(downloadedBytes, "Method7_ClickBasedDownload", data, cancellationToken);
                            successfulMethods.Add("Method7_ClickBasedDownload");
                            if (firstSuccessfulPdf == null) firstSuccessfulPdf = downloadedBytes;
                        }
                        else
                        {
                            _logger.LogWarning(" METHOD 7 FAILED: Downloaded file is not a valid PDF");
                        }
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 7 FAILED: No downloaded file found");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 7 EXCEPTION: Click-based download failed - {Message}", ex.Message);
                }
                
                // Method 8: Final aggressive PDF scan as last resort
                _logger.LogInformation("=== METHOD 8: Aggressive PDF scan as final fallback ===");
                try
                {
                    var scanResult = await PerformAggressivePdfScan(downloadDir, downloadsFolder, cancellationToken);
                    if (scanResult != null && scanResult.Bytes.Length > 0)
                    {
                        _logger.LogInformation(" METHOD 8 SUCCESS: Aggressive scan - {FileSize} bytes", scanResult.Bytes.Length);
                        await SavePdfWithMethodIdentifier(scanResult.Bytes, "Method8_AggressiveScan", data, cancellationToken);
                        successfulMethods.Add("Method8_AggressiveScan");
                        if (firstSuccessfulPdf == null) firstSuccessfulPdf = scanResult.Bytes;
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 8 FAILED: Aggressive scan returned null or empty");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 8 EXCEPTION: Aggressive scan failed - {Message}", ex.Message);
                }

                // Method 9: Additional comprehensive methods
                _logger.LogInformation("=== METHOD 9: Additional comprehensive browser capture methods ===");
                
                // Method 9a: Browser viewer capture
                try
                {
                    var pdfBytes = await TryCapturePdfFromBrowserViewer(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation(" METHOD 9a SUCCESS: Browser viewer capture - {FileSize} bytes", pdfBytes.Length);
                        await SavePdfWithMethodIdentifier(pdfBytes, "Method9a_BrowserViewer", data, cancellationToken);
                        successfulMethods.Add("Method9a_BrowserViewer");
                        if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 9a FAILED: Browser viewer capture returned null or empty");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 9a EXCEPTION: Browser viewer capture failed - {Message}", ex.Message);
                }

                // Method 9b: Direct openPDFNoticeWindow execution
                try
                {
                    var pdfBytes = await TryExecuteOpenPDFNoticeWindow(pdfLinkElement, cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation(" METHOD 9b SUCCESS: openPDFNoticeWindow execution - {FileSize} bytes", pdfBytes.Length);
                        await SavePdfWithMethodIdentifier(pdfBytes, "Method9b_OpenPDFNoticeWindow", data, cancellationToken);
                        successfulMethods.Add("Method9b_OpenPDFNoticeWindow");
                        if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 9b FAILED: openPDFNoticeWindow execution returned null or empty");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 9b EXCEPTION: openPDFNoticeWindow execution failed - {Message}", ex.Message);
                }

                // Method 9c: Direct PDF URL extraction
                try
                {
                    var pdfBytes = await TryDirectPdfUrlExtraction(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation(" METHOD 9c SUCCESS: Direct PDF URL extraction - {FileSize} bytes", pdfBytes.Length);
                        await SavePdfWithMethodIdentifier(pdfBytes, "Method9c_DirectUrlExtraction", data, cancellationToken);
                        successfulMethods.Add("Method9c_DirectUrlExtraction");
                        if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 9c FAILED: Direct PDF URL extraction returned null or empty");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 9c EXCEPTION: Direct PDF URL extraction failed - {Message}", ex.Message);
                }

                // Method 9d: Open PDF tab capture
                try
                {
                    var pdfBytes = await TryCapturePdfFromOpenTab(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation(" METHOD 9d SUCCESS: Open tab capture - {FileSize} bytes", pdfBytes.Length);
                        await SavePdfWithMethodIdentifier(pdfBytes, "Method9d_OpenTabCapture", data, cancellationToken);
                        successfulMethods.Add("Method9d_OpenTabCapture");
                        if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 9d FAILED: Open tab capture returned null or empty");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 9d EXCEPTION: Open tab capture failed - {Message}", ex.Message);
                }

                // Method 9e: Print PDF from opened window
                try
                {
                    var pdfBytes = await TryPrintPdfFromOpenedWindow(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation(" METHOD 9e SUCCESS: Print PDF from opened window - {FileSize} bytes", pdfBytes.Length);
                        await SavePdfWithMethodIdentifier(pdfBytes, "Method9e_PrintFromWindow", data, cancellationToken);
                        successfulMethods.Add("Method9e_PrintFromWindow");
                        if (firstSuccessfulPdf == null) firstSuccessfulPdf = pdfBytes;
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 9e FAILED: Print PDF from opened window returned null or empty");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 9e EXCEPTION: Print PDF from opened window failed - {Message}", ex.Message);
                }

                // Method 10: Final fallback checks
                _logger.LogInformation("=== METHOD 10: Final fallback checks ===");
                
                // Method 10a: Check Downloads folder for recently downloaded PDFs
                try
                {
                    var fallbackDownloadedFile = await CheckDownloadsFolderForRecentPdf(downloadsFolder, cancellationToken);
                    if (!string.IsNullOrEmpty(fallbackDownloadedFile))
                    {
                        var fallbackDownloadedBytes = await File.ReadAllBytesAsync(fallbackDownloadedFile, cancellationToken);
                        if (IsValidPdf(fallbackDownloadedBytes))
                        {
                            _logger.LogInformation(" METHOD 10a SUCCESS: Found recently downloaded PDF in Downloads folder - {FilePath}, Size: {FileSize} bytes", 
                                fallbackDownloadedFile, fallbackDownloadedBytes.Length);
                            await SavePdfWithMethodIdentifier(fallbackDownloadedBytes, "Method10a_RecentDownloadsScan", data, cancellationToken);
                            successfulMethods.Add("Method10a_RecentDownloadsScan");
                            if (firstSuccessfulPdf == null) firstSuccessfulPdf = fallbackDownloadedBytes;
                        }
                        else
                        {
                            _logger.LogWarning(" METHOD 10a FAILED: Found file but it's not a valid PDF");
                        }
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 10a FAILED: No recently downloaded PDF found in Downloads folder");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 10a EXCEPTION: Downloads folder scan failed - {Message}", ex.Message);
                }

                // Method 10b: Final aggressive scan
                try
                {
                    var aggressiveScanResult = await PerformAggressivePdfScan(downloadDir, downloadsFolder, cancellationToken);
                    if (aggressiveScanResult != null)
                    {
                        _logger.LogInformation(" METHOD 10b SUCCESS: Found PDF via aggressive scan - {FilePath}, Size: {FileSize} bytes", 
                            aggressiveScanResult.FilePath, aggressiveScanResult.FileSize);
                        await SavePdfWithMethodIdentifier(aggressiveScanResult.Bytes, "Method10b_FinalAggressiveScan", data, cancellationToken);
                        successfulMethods.Add("Method10b_FinalAggressiveScan");
                        if (firstSuccessfulPdf == null) firstSuccessfulPdf = aggressiveScanResult.Bytes;
                    }
                    else
                    {
                        _logger.LogWarning(" METHOD 10b FAILED: Final aggressive scan returned null");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(" METHOD 10b EXCEPTION: Final aggressive scan failed - {Message}", ex.Message);
                }

                // Summary of results
                _logger.LogInformation(" DOWNLOAD SUMMARY: {SuccessfulMethodsCount} methods succeeded: {SuccessfulMethods}", 
                    successfulMethods.Count, string.Join(", ", successfulMethods));

                // Return the first successful PDF, or null if none succeeded
                if (firstSuccessfulPdf != null)
                {
                    _logger.LogInformation(" OVERALL SUCCESS: Returning PDF from first successful method ({FileSize} bytes)", firstSuccessfulPdf.Length);
                    return firstSuccessfulPdf;
                }
                else
                {
                    _logger.LogError(" OVERALL FAILURE: All PDF download methods failed");
                    throw new Exception("All PDF download methods failed");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError("Selenium PDF download failed: {Message}", ex.Message);
                return null;
            }
            finally
            {
                // Cleanup download directory
                if (!string.IsNullOrEmpty(downloadDir) && Directory.Exists(downloadDir))
                {
                    try
                    {
                        Directory.Delete(downloadDir, true);
                        _logger.LogDebug("Cleaned up download directory: {DownloadDir}", downloadDir);
                    }
                    catch (Exception cleanupEx)
                    {
                        _logger.LogWarning("Failed to cleanup download directory: {Message}", cleanupEx.Message);
                    }
                }
            }
        }

        private async Task<byte[]?> TryWindowBasedPdfCapture(IWebElement pdfLinkElement, CancellationToken cancellationToken)
        {
            try
            {
                var href = pdfLinkElement.GetAttribute("href");
                if (string.IsNullOrEmpty(href))
                {
                    return null;
                }
                _logger.LogInformation("Attempting window-based PDF capture from URL: {Url}", href);
                
                // Store current window handle
                var originalWindow = Driver?.CurrentWindowHandle;
                var originalWindows = Driver?.WindowHandles.ToList();
                
                // Handle relative URLs
                if (href.StartsWith("/"))
                {
                    var baseUri = new Uri(Driver?.Url ?? "https://sa.www4.irs.gov");
                    href = new Uri(baseUri, href).ToString();
                }
                
                // Open PDF in new tab using JavaScript
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                _logger.LogInformation("Opening PDF link in new tab: {Url}", href);
                jsExecutor?.ExecuteScript($"window.open('{href}', '_blank');");
                
                // Wait longer for the new tab to open and load
                await Task.Delay(8000, cancellationToken); // Increased delay to 8 seconds
                
                // Find the new window
                var newWindows = Driver?.WindowHandles.ToList();
                var pdfWindow = newWindows?.FirstOrDefault(w => !originalWindows.Contains(w));
                
                if (!string.IsNullOrEmpty(pdfWindow))
                {
                    _logger.LogInformation("Successfully opened new window for PDF: {WindowHandle}", pdfWindow);
                }
                else
                {
                    _logger.LogWarning("No new window found after opening PDF link. Attempting to retry...");
                    // Retry opening the PDF link
                    jsExecutor?.ExecuteScript($"window.open('{href}', '_blank');");
                    await Task.Delay(8000, cancellationToken); // Increased delay to 8 seconds
                    newWindows = Driver?.WindowHandles.ToList();
                    pdfWindow = newWindows?.FirstOrDefault(w => !originalWindows.Contains(w));
                    
                    if (!string.IsNullOrEmpty(pdfWindow))
                    {
                        _logger.LogInformation("Successfully opened new window for PDF on retry: {WindowHandle}", pdfWindow);
                    }
                    else
                    {
                        _logger.LogError("Failed to open new window for PDF after retry");
                        return null;
                    }
                }
                
                if (!string.IsNullOrEmpty(pdfWindow))
                {
                    try
                    {
                        Driver?.SwitchTo().Window(pdfWindow);
                        
                        // Wait for the page to fully load and check if it's a PDF
                        await Task.Delay(8000, cancellationToken); // Increased delay to 8 seconds
                        
                        // Check if we're on a PDF page by examining the URL and content
                        var currentUrl = Driver?.Url ?? "";
                        var pageSource = Driver?.PageSource ?? "";
                        
                        _logger.LogInformation("Opened window URL: {Url}", currentUrl);
                        _logger.LogInformation("Page source length: {Length}", pageSource.Length);
                        
                        // Wait for PDF to be fully loaded - check for PDF indicators
                        var maxWaitTime = 30000; // 30 seconds
                        var waitInterval = 2000; // 2 seconds
                        var totalWaited = 0;
                        var pdfDetected = false;
                        
                        while (totalWaited < maxWaitTime && !pdfDetected)
                        {
                            // Check if page is still loading
                            var readyState = jsExecutor?.ExecuteScript("return document.readyState")?.ToString();
                            if (readyState == "complete")
                            {
                                // Check for PDF indicators
                                var hasPdfViewer = jsExecutor?.ExecuteScript("return document.querySelector('embed[type=\"application/pdf\"]') !== null")?.ToString() == "True";
                                var hasPdfObject = jsExecutor?.ExecuteScript("return document.querySelector('object[type=\"application/pdf\"]') !== null")?.ToString() == "True";
                                var hasPdfIframe = jsExecutor?.ExecuteScript("return document.querySelector('iframe[src*=\".pdf\"]') !== null")?.ToString() == "True";
                                var urlContainsPdf = currentUrl.ToLower().Contains(".pdf");
                                var hasPdfContent = jsExecutor?.ExecuteScript("return document.body.innerHTML.includes('PDF') || document.body.innerHTML.includes('pdf')")?.ToString() == "True";
                                
                                _logger.LogInformation("PDF detection check - Viewer: {HasViewer}, Object: {HasObject}, Iframe: {HasIframe}, URL: {UrlContains}, Content: {HasContent}", 
                                    hasPdfViewer, hasPdfObject, hasPdfIframe, urlContainsPdf, hasPdfContent);
                                
                                if (hasPdfViewer || hasPdfObject || hasPdfIframe || urlContainsPdf || hasPdfContent)
                                {
                                    _logger.LogInformation("PDF detected, proceeding with capture methods");
                                    pdfDetected = true;
                                    break;
                                }
                            }
                            
                            await Task.Delay(waitInterval, cancellationToken);
                            totalWaited += waitInterval;
                            _logger.LogInformation("Waiting for PDF to load... ({TotalWaited}ms/{MaxWaitTime}ms)", totalWaited, maxWaitTime);
                        }
                        
                        if (!pdfDetected)
                        {
                            _logger.LogWarning("PDF not detected after waiting {MaxWaitTime}ms, but proceeding with capture attempts", maxWaitTime);
                        }
                        
                        // Additional wait to ensure PDF is fully rendered
                        await Task.Delay(3000, cancellationToken);
                        
                        // Method 1: Try Chrome DevTools PDF capture (most reliable for PDFs)
                        _logger.LogInformation("Attempting Method 1: Chrome DevTools PDF capture");
                        var pdfBytes = await TryChromeDevToolsPdfCapture(cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Successfully captured PDF using Chrome DevTools: {FileSize} bytes", pdfBytes.Length);
                            return pdfBytes;
                        }
                        
                        // Method 2: Try to get PDF content via JavaScript (if PDF is embedded)
                        _logger.LogInformation("Attempting Method 2: JavaScript PDF extraction");
                        pdfBytes = await TryExtractPdfFromPage(cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Successfully extracted PDF from page: {FileSize} bytes", pdfBytes.Length);
                            return pdfBytes;
                        }
                        
                        // Method 3: Use print-to-PDF functionality
                        _logger.LogInformation("Attempting Method 3: Print-to-PDF");
                        pdfBytes = await TryPrintToPdf(cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Successfully printed PDF to PDF: {FileSize} bytes", pdfBytes.Length);
                            return pdfBytes;
                        }
                        
                        // Method 4: Try to trigger download from the PDF viewer
                        _logger.LogInformation("Attempting Method 4: PDF viewer download trigger");
                        pdfBytes = await TryTriggerDownloadFromPdfViewer(cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            return pdfBytes;
                        }
                        
                        // Method 5: Try to capture using print dialog
                        _logger.LogInformation("Attempting Method 5: Print dialog capture");
                        pdfBytes = await TryCapturePdfFromPrintDialog(cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Successfully captured PDF from print dialog: {FileSize} bytes", pdfBytes.Length);
                            return pdfBytes;
                        }
                        
                        // Method 6: Try to capture from PDF viewer controls
                        _logger.LogInformation("Attempting Method 6: Browser viewer capture");
                        pdfBytes = await TryCapturePdfFromBrowserViewer(cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Successfully captured PDF from viewer controls: {FileSize} bytes", pdfBytes.Length);
                            return pdfBytes;
                        }
                        
                        // Method 7: Try to print PDF from opened window
                        _logger.LogInformation("Attempting Method 7: Print from opened window");
                        pdfBytes = await TryPrintPdfFromOpenedWindow(cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Successfully printed PDF from opened window: {FileSize} bytes", pdfBytes.Length);
                            return pdfBytes;
                        }
                        
                        _logger.LogWarning("All PDF capture methods failed in window-based capture");
                    }
                    finally
                    {
                        // Close the PDF window and switch back
                        try
                        {
                            Driver?.Close();
                            Driver?.SwitchTo().Window(originalWindow);
                        }
                        catch (Exception switchEx)
                        {
                            _logger.LogWarning("Failed to close PDF window: {Message}", switchEx.Message);
                        }
                    }
                }
                else
                {
                    _logger.LogWarning("No new window found after opening PDF link");
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Window-based PDF capture failed: {Message}", ex.Message);
            }
            return null;
        }

        // New method to click PDF link and capture from current window
        private async Task<byte[]?> TryClickAndCaptureFromCurrentWindow(IWebElement pdfLinkElement, CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting to click PDF link and capture from current window");
                
                // Store current URL
                var originalUrl = Driver?.Url;
                
                // Click the PDF link (this might navigate in the same window)
                pdfLinkElement.Click();
                await Task.Delay(8000, cancellationToken); // Increased delay to 8 seconds for navigation
                
                // Check if we navigated to a new page
                var newUrl = Driver?.Url;
                if (newUrl != originalUrl)
                {
                    _logger.LogInformation("Navigation detected to: {NewUrl}", newUrl);
                    
                    // Wait for page to load
                    await Task.Delay(8000, cancellationToken); // Increased delay to 8 seconds for page loading
                    
                    // Try Chrome DevTools PDF capture
                    var pdfBytes = await TryChromeDevToolsPdfCapture(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully captured PDF from current window: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    // Try other capture methods
                    pdfBytes = await TryExtractPdfFromPage(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryPrintToPdf(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        return pdfBytes;
                    }
                }
                else
                {
                    _logger.LogInformation("No navigation detected, PDF might have opened in new window or failed to load");
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Click and capture from current window failed: {Message}", ex.Message);
            }
            return null;
        }

        // New method specifically for printing PDF from opened window
        private async Task<byte[]?> TryPrintPdfFromOpenedWindow(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting to print PDF from opened window");
                
                // Method 1: Use Chrome DevTools Protocol to print to PDF
                if (Driver is ChromeDriver chromeDriver)
                {
                    var chromeDriverType = chromeDriver.GetType();
                    var executeChromeCommandMethod = chromeDriverType.GetMethod("ExecuteChromeCommand",
                        new Type[] { typeof(string), typeof(Dictionary<string, object>) });
                    
                    if (executeChromeCommandMethod != null)
                    {
                        var printParams = new Dictionary<string, object>
                        {
                            ["landscape"] = false,
                            ["displayHeaderFooter"] = false,
                            ["printBackground"] = true,
                            ["preferCSSPageSize"] = true,
                            ["paperWidth"] = 8.5,
                            ["paperHeight"] = 11,
                            ["marginTop"] = 0.4,
                            ["marginBottom"] = 0.4,
                            ["marginLeft"] = 0.4,
                            ["marginRight"] = 0.4,
                            ["scale"] = 1.0
                        };
                        
                        var result = executeChromeCommandMethod.Invoke(chromeDriver,
                            new object[] { "Page.printToPDF", printParams });
                        
                        if (result is Dictionary<string, object> printResult &&
                            printResult.TryGetValue("data", out var base64Data))
                        {
                            var pdfBytes = Convert.FromBase64String(base64Data.ToString());
                            if (IsValidPdf(pdfBytes))
                            {
                                _logger.LogInformation("Successfully printed PDF from opened window: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                        }
                    }
                }
                
                // Method 2: Try keyboard shortcut Ctrl+P and capture
                var actions = new OpenQA.Selenium.Interactions.Actions(Driver);
                actions.KeyDown(Keys.Control).SendKeys("p").KeyUp(Keys.Control).Perform();
                await Task.Delay(2000, cancellationToken);
                
                // Try to find and click "Save as PDF" option
                var saveAsPdfSelectors = new[]
                {
                    "//button[contains(text(), 'Save as PDF')]",
                    "//button[contains(text(), 'Save')]",
                    "//*[contains(text(), 'Save as PDF')]",
                    "//*[@id='save-as-pdf']",
                    "//button[@aria-label='Save as PDF']",
                    "//button[contains(@class, 'save-pdf')]"
                };
                
                foreach (var selector in saveAsPdfSelectors)
                {
                    try
                    {
                        var saveBtn = Driver?.FindElement(By.XPath(selector));
                        if (saveBtn != null && saveBtn.Displayed && saveBtn.Enabled)
                        {
                            saveBtn.Click();
                            _logger.LogInformation("Clicked Save as PDF button using selector: {Selector}", selector);
                            await Task.Delay(3000, cancellationToken);
                            break;
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("Save as PDF button selector {Selector} failed: {Message}", selector, ex.Message);
                    }
                }
                
                // Method 3: Try to find and click print button in PDF viewer
                var printSelectors = new[]
                {
                    "//button[@title='Print']",
                    "//button[contains(@class, 'print')]",
                    "//a[@title='Print']",
                    "//a[contains(@class, 'print')]",
                    "//*[contains(text(), 'Print')]",
                    "//*[@id='print']",
                    "//button[@aria-label='Print']"
                };
                
                foreach (var selector in printSelectors)
                {
                    try
                    {
                        var printBtn = Driver?.FindElement(By.XPath(selector));
                        if (printBtn != null && printBtn.Displayed && printBtn.Enabled)
                        {
                            printBtn.Click();
                            _logger.LogInformation("Clicked Print button using selector: {Selector}", selector);
                            await Task.Delay(2000, cancellationToken);
                            
                            // After clicking print, try to capture the print dialog
                            var pdfBytes = await TryCapturePdfFromPrintDialog(cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                return pdfBytes;
                            }
                            break;
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("Print button selector {Selector} failed: {Message}", selector, ex.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Print PDF from opened window failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryExtractPdfFromPage(CancellationToken cancellationToken)
        {
            try
            {
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                // Check if page contains PDF content
                var pageSource = Driver?.PageSource?.ToLower() ?? "";
                if (pageSource.Contains("application/pdf") || pageSource.Contains("%pdf"))
                {
                    _logger.LogInformation("Page appears to contain PDF content");
                    // Try to extract PDF data if it's embedded
                    var script = @"
                        var pdfData = null;
                        var embeds = document.getElementsByTagName('embed');
                        for (var i = 0; i < embeds.length; i++) {
                            if (embeds[i].type === 'application/pdf') {
                                pdfData = embeds[i].src;
                                break;
                            }
                        }
                        if (!pdfData) {
                            var objects = document.getElementsByTagName('object');
                            for (var i = 0; i < objects.length; i++) {
                                if (objects[i].type === 'application/pdf') {
                                    pdfData = objects[i].data;
                                    break;
                                }
                            }
                        }
                        return pdfData;
                    ";
                    var pdfSrc = jsExecutor?.ExecuteScript(script)?.ToString();
                    if (!string.IsNullOrEmpty(pdfSrc))
                    {
                        _logger.LogInformation("Found embedded PDF source: {PdfSrc}", pdfSrc);
                        // Download the PDF content directly
                        return await DownloadPdfFromUrl(pdfSrc, cancellationToken);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF extraction from page failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryTriggerDownloadFromPdfViewer(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting to capture PDF from browser viewer");
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // Method 1: Try to extract PDF content directly from the page
                var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                if (pdfBytes != null && pdfBytes.Length > 0)
                {
                    _logger.LogInformation("Successfully extracted PDF content from viewer: {FileSize} bytes", pdfBytes.Length);
                    return pdfBytes;
                }

                // Method 2: Try keyboard shortcut Ctrl+S (Save As)
                var actions = new OpenQA.Selenium.Interactions.Actions(Driver);
                actions.KeyDown(Keys.Control).SendKeys("s").KeyUp(Keys.Control).Perform();
                await Task.Delay(2000, cancellationToken);
                
                // Method 3: Try to find and click download button in PDF viewer
                var downloadSelectors = new[]
                {
                    "//button[@title='Download']",
                    "//button[contains(@class, 'download')]",
                    "//a[@title='Download']",
                    "//a[contains(@class, 'download')]",
                    "//*[contains(text(), 'Download')]",
                    "//*[@id='download']",
                    "//button[contains(@aria-label, 'Download')]",
                    "//a[contains(@aria-label, 'Download')]"
                };
                
                foreach (var selector in downloadSelectors)
                {
                    try
                    {
                        var downloadBtn = Driver?.FindElement(By.XPath(selector));
                        if (downloadBtn != null && downloadBtn.Displayed && downloadBtn.Enabled)
                        {
                            downloadBtn.Click();
                            _logger.LogInformation("Clicked download button in PDF viewer using selector: {Selector}", selector);
                            await Task.Delay(3000, cancellationToken);
                            break;
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("Download button selector {Selector} failed: {Message}", selector, ex.Message);
                    }
                }

                // Method 4: Try to trigger print dialog and capture as PDF
                pdfBytes = await TryCapturePdfFromPrintDialog(cancellationToken);
                if (pdfBytes != null && pdfBytes.Length > 0)
                {
                    _logger.LogInformation("Successfully captured PDF from print dialog: {FileSize} bytes", pdfBytes.Length);
                    return pdfBytes;
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF viewer download trigger failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryExtractPdfContentFromViewer(CancellationToken cancellationToken)
        {
            try
            {
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // Enhanced JavaScript to extract PDF content from various sources
                var script = @"
                    function extractPdfContent() {
                        // Method 1: Extract PDF URL from openPDFNoticeWindow function
                        var pdfLinks = document.querySelectorAll('a[onclick*=""openPDFNoticeWindow""]');
                        for (var i = 0; i < pdfLinks.length; i++) {
                            var onclick = pdfLinks[i].getAttribute('onclick');
                            if (onclick) {
                                var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                if (match && match[1]) {
                                    var pdfUrl = match[1];
                                    // Handle relative URLs
                                    if (pdfUrl.startsWith('/')) {
                                        pdfUrl = window.location.origin + pdfUrl;
                                    }
                                    return { type: 'openPDFNoticeWindow', src: pdfUrl, element: pdfLinks[i].href };
                                }
                            }
                        }
                        
                        // Method 2: Extract from CP575 links specifically
                        var cp575Links = document.querySelectorAll('a[href*=""CP575""]');
                        for (var i = 0; i < cp575Links.length; i++) {
                            var href = cp575Links[i].href;
                            if (href && (href.includes('.pdf') || href.includes('CP575'))) {
                                return { type: 'cp575', src: href };
                            }
                        }
                        
                        // Method 3: Check for embedded PDF data
                        var embeds = document.getElementsByTagName('embed');
                        for (var i = 0; i < embeds.length; i++) {
                            if (embeds[i].type === 'application/pdf') {
                                return { type: 'embed', src: embeds[i].src, data: embeds[i].data };
                            }
                        }
                        
                        // Method 4: Check for object tags
                        var objects = document.getElementsByTagName('object');
                        for (var i = 0; i < objects.length; i++) {
                            if (objects[i].type === 'application/pdf') {
                                return { type: 'object', src: objects[i].data, data: objects[i].data };
                            }
                        }
                        
                        // Method 5: Check for iframe with PDF
                        var iframes = document.getElementsByTagName('iframe');
                        for (var i = 0; i < iframes.length; i++) {
                            var src = iframes[i].src;
                            if (src && (src.includes('.pdf') || src.includes('application/pdf'))) {
                                return { type: 'iframe', src: src };
                            }
                        }
                        
                        // Method 6: Check for PDF viewer elements
                        var pdfViewers = document.querySelectorAll('[data-pdf-url], [data-pdf-src]');
                        for (var i = 0; i < pdfViewers.length; i++) {
                            var pdfUrl = pdfViewers[i].getAttribute('data-pdf-url') || pdfViewers[i].getAttribute('data-pdf-src');
                            if (pdfUrl) {
                                return { type: 'viewer', src: pdfUrl };
                            }
                        }
                        
                        // Method 7: Check current URL for PDF
                        if (window.location.href.includes('.pdf') || window.location.href.includes('application/pdf')) {
                            return { type: 'url', src: window.location.href };
                        }
                        
                        // Method 8: Look for any PDF links in the page
                        var allLinks = document.querySelectorAll('a[href*="".pdf""]');
                        for (var i = 0; i < allLinks.length; i++) {
                            var href = allLinks[i].href;
                            if (href && href.includes('.pdf')) {
                                return { type: 'generic', src: href };
                            }
                        }
                        
                        return null;
                    }
                    return extractPdfContent();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null)
                {
                    _logger.LogInformation("Found PDF content source: {Result}", result);
                    
                    // If we found a PDF source, try to download it
                    if (result is Dictionary<string, object> pdfInfo)
                    {
                        var src = pdfInfo.GetValueOrDefault("src")?.ToString();
                        if (!string.IsNullOrEmpty(src))
                        {
                            return await DownloadPdfFromUrl(src, cancellationToken);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF content extraction failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryCapturePdfFromPrintDialog(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting to capture PDF from print dialog");
                
                // Method 1: Use Chrome DevTools Protocol to print to PDF
                if (Driver is ChromeDriver chromeDriver)
                {
                    var chromeDriverType = chromeDriver.GetType();
                    var executeChromeCommandMethod = chromeDriverType.GetMethod("ExecuteChromeCommand",
                        new Type[] { typeof(string), typeof(Dictionary<string, object>) });
                    
                    if (executeChromeCommandMethod != null)
                    {
                        var printParams = new Dictionary<string, object>
                        {
                            ["landscape"] = false,
                            ["displayHeaderFooter"] = false,
                            ["printBackground"] = true,
                            ["preferCSSPageSize"] = true,
                            ["paperWidth"] = 8.5,
                            ["paperHeight"] = 11,
                            ["marginTop"] = 0.4,
                            ["marginBottom"] = 0.4,
                            ["marginLeft"] = 0.4,
                            ["marginRight"] = 0.4,
                            ["scale"] = 1.0
                        };
                        
                        var result = executeChromeCommandMethod.Invoke(chromeDriver,
                            new object[] { "Page.printToPDF", printParams });
                        
                        if (result is Dictionary<string, object> printResult &&
                            printResult.TryGetValue("data", out var base64Data))
                        {
                            var pdfBytes = Convert.FromBase64String(base64Data.ToString());
                            if (IsValidPdf(pdfBytes))
                            {
                                _logger.LogInformation("Successfully captured PDF from print dialog: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                        }
                    }
                }
                
                // Method 2: Try keyboard shortcut Ctrl+P and capture
                var actions = new OpenQA.Selenium.Interactions.Actions(Driver);
                actions.KeyDown(Keys.Control).SendKeys("p").KeyUp(Keys.Control).Perform();
                await Task.Delay(2000, cancellationToken);
                
                // Try to find and click "Save as PDF" option
                var saveAsPdfSelectors = new[]
                {
                    "//button[contains(text(), 'Save as PDF')]",
                    "//button[contains(text(), 'Save')]",
                    "//*[contains(text(), 'Save as PDF')]",
                    "//*[@id='save-as-pdf']"
                };
                
                foreach (var selector in saveAsPdfSelectors)
                {
                    try
                    {
                        var saveBtn = Driver?.FindElement(By.XPath(selector));
                        if (saveBtn != null && saveBtn.Displayed && saveBtn.Enabled)
                        {
                            saveBtn.Click();
                            _logger.LogInformation("Clicked Save as PDF button");
                            await Task.Delay(3000, cancellationToken);
                            break;
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("Save as PDF button selector {Selector} failed: {Message}", selector, ex.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Print dialog PDF capture failed: {Message}", ex.Message);
            }
            return null;
        }

        private Task<byte[]?> TryPrintToPdf(CancellationToken cancellationToken)
        {
            try
            {
                if (Driver is ChromeDriver chromeDriver)
                {
                    _logger.LogInformation("Attempting to print page to PDF");
                    // Try to use Chrome DevTools Protocol to print to PDF
                    var chromeDriverType = chromeDriver.GetType();
                    var executeChromeCommandMethod = chromeDriverType.GetMethod("ExecuteChromeCommand",
                        new Type[] { typeof(string), typeof(Dictionary<string, object>) });
                    if (executeChromeCommandMethod != null)
                    {
                        var printParams = new Dictionary<string, object>
                        {
                            ["landscape"] = false,
                            ["displayHeaderFooter"] = false,
                            ["printBackground"] = true,
                            ["preferCSSPageSize"] = true
                        };
                        var result = executeChromeCommandMethod.Invoke(chromeDriver,
                            new object[] { "Page.printToPDF", printParams });
                        if (result is Dictionary<string, object> printResult &&
                            printResult.TryGetValue("data", out var base64Data))
                        {
                            var pdfBytes = Convert.FromBase64String(base64Data.ToString());
                            _logger.LogInformation("Successfully printed page to PDF: {FileSize} bytes", pdfBytes.Length);
                            return Task.FromResult<byte[]?>(pdfBytes);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Print to PDF failed: {Message}", ex.Message);
            }
            return Task.FromResult<byte[]?>(null);
        }

        private async Task<byte[]?> TryCapturePdfFromOpenTab(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Searching for open PDF tabs");
                var originalWindow = Driver?.CurrentWindowHandle;
                var allWindows = Driver?.WindowHandles.ToList() ?? new List<string>();
                foreach (var windowHandle in allWindows)
                {
                    try
                    {
                        Driver?.SwitchTo().Window(windowHandle);
                        var currentUrl = Driver?.Url?.ToLower() ?? "";
                        _logger.LogDebug("Checking window with URL: {Url}", currentUrl);
                        if (currentUrl.Contains(".pdf") || currentUrl.Contains("cp575"))
                        {
                            _logger.LogInformation("Found PDF tab: {Url}", currentUrl);
                            
                            // Method 1: Try to download from this URL directly
                            var pdfBytes = await DownloadPdfFromUrl(Driver?.Url, cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Successfully downloaded PDF from URL: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                            
                            // Method 2: Try to extract PDF content from the page
                            pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Successfully extracted PDF content from page: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                            
                            // Method 3: Try print to PDF using Chrome DevTools
                            pdfBytes = await TryPrintToPdf(cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Successfully printed PDF to PDF: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                            
                            // Method 4: Try to capture from PDF viewer controls
                            pdfBytes = await TryTriggerDownloadFromPdfViewer(cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Successfully captured PDF from viewer controls: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                            
                            // Method 5: Try to capture using print dialog
                            pdfBytes = await TryCapturePdfFromPrintDialog(cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Successfully captured PDF from print dialog: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("Error checking window {WindowHandle}: {Message}", windowHandle, ex.Message);
                    }
                }
                // Switch back to original window
                if (!string.IsNullOrEmpty(originalWindow))
                {
                    try
                    {
                        Driver?.SwitchTo().Window(originalWindow);
                    }
                    catch (Exception switchEx)
                    {
                        _logger.LogWarning("Failed to switch back to original window: {Message}", switchEx.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning("PDF tab capture failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryExecuteOpenPDFNoticeWindow(IWebElement pdfLinkElement, CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting to execute openPDFNoticeWindow function directly");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // Method 1: Extract PDF URL from onclick attribute
                var onclick = pdfLinkElement.GetAttribute("onclick");
                if (!string.IsNullOrEmpty(onclick))
                {
                    var match = Regex.Match(onclick, @"openPDFNoticeWindow\('([^']+)'\)");
                    if (match.Success)
                    {
                        var pdfUrl = match.Groups[1].Value;
                        _logger.LogInformation("Extracted PDF URL from openPDFNoticeWindow: {PdfUrl}", pdfUrl);
                        
                        // Handle relative URLs
                        if (pdfUrl.StartsWith("/"))
                        {
                            var baseUri = new Uri(Driver?.Url ?? "https://sa.www4.irs.gov");
                            pdfUrl = new Uri(baseUri, pdfUrl).ToString();
                        }
                        
                        // Try to download the PDF directly
                        var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Successfully downloaded PDF via openPDFNoticeWindow URL: {FileSize} bytes", pdfBytes.Length);
                            return pdfBytes;
                        }
                    }
                }
                
                // Method 2: Execute the openPDFNoticeWindow function directly
                var script = @"
                    function executeOpenPDFNoticeWindow() {
                        try {
                            // Find the PDF link with openPDFNoticeWindow
                            var pdfLink = document.querySelector('a[onclick*=""openPDFNoticeWindow""]');
                            if (pdfLink) {
                                var onclick = pdfLink.getAttribute('onclick');
                                if (onclick) {
                                    var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                    if (match && match[1]) {
                                        var pdfUrl = match[1];
                                        // Handle relative URLs
                                        if (pdfUrl.startsWith('/')) {
                                            pdfUrl = window.location.origin + pdfUrl;
                                        }
                                        return { success: true, url: pdfUrl };
                                    }
                                }
                            }
                            return { success: false, error: 'No openPDFNoticeWindow found' };
                        } catch (e) {
                            return { success: false, error: e.message };
                        }
                    }
                    return executeOpenPDFNoticeWindow();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    if (jsResult.TryGetValue("success", out var success) && success is bool isSuccess && isSuccess)
                    {
                        if (jsResult.TryGetValue("url", out var url) && url is string pdfUrl)
                        {
                            _logger.LogInformation("Successfully extracted PDF URL via JavaScript: {PdfUrl}", pdfUrl);
                            
                            var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Successfully downloaded PDF via JavaScript extraction: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                        }
                    }
                }
                
                // Method 3: Try to execute the onclick function directly
                try
                {
                    jsExecutor?.ExecuteScript("arguments[0].click();", pdfLinkElement);
                    await Task.Delay(3000, cancellationToken);
                    
                    // Check if a new window/tab opened
                    var newWindows = Driver?.WindowHandles.ToList();
                    var originalWindows = Driver?.WindowHandles.ToList();
                    
                    if (newWindows != null && newWindows.Count > originalWindows?.Count)
                    {
                        var newWindow = newWindows.FirstOrDefault(w => !originalWindows.Contains(w));
                        if (!string.IsNullOrEmpty(newWindow))
                        {
                            Driver?.SwitchTo().Window(newWindow);
                            await Task.Delay(2000, cancellationToken);
                            
                            var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Successfully captured PDF from new window: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                            
                            // Close the new window and switch back
                            Driver?.Close();
                            Driver?.SwitchTo().Window(originalWindows.First());
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogDebug("Direct onclick execution failed: {Message}", ex.Message);
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("openPDFNoticeWindow execution failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryDirectPdfUrlExtraction(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting direct PDF URL extraction from page");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // JavaScript to extract the exact PDF URL from the page
                var script = @"
                    function extractDirectPdfUrl() {
                        try {
                            // Method 1: Look for the exact link with 'CLICK HERE for Your EIN Confirmation Letter'
                            var confirmationLinks = document.querySelectorAll('a');
                            for (var i = 0; i < confirmationLinks.length; i++) {
                                var link = confirmationLinks[i];
                                var text = link.textContent || link.innerText || '';
                                if (text.includes('CLICK HERE for Your EIN Confirmation Letter')) {
                                    var onclick = link.getAttribute('onclick');
                                    if (onclick) {
                                        var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                        if (match && match[1]) {
                                            var pdfUrl = match[1];
                                            if (pdfUrl.startsWith('/')) {
                                                pdfUrl = window.location.origin + pdfUrl;
                                            }
                                            return { success: true, url: pdfUrl, method: 'confirmation_link' };
                                        }
                                    }
                                }
                            }
                            
                            // Method 2: Look for any link with CP575 in onclick
                            var cp575Links = document.querySelectorAll('a[onclick*=""CP575""]');
                            for (var i = 0; i < cp575Links.length; i++) {
                                var onclick = cp575Links[i].getAttribute('onclick');
                                if (onclick) {
                                    var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                    if (match && match[1]) {
                                        var pdfUrl = match[1];
                                        if (pdfUrl.startsWith('/')) {
                                            pdfUrl = window.location.origin + pdfUrl;
                                        }
                                        return { success: true, url: pdfUrl, method: 'cp575_onclick' };
                                    }
                                }
                            }
                            
                            // Method 3: Search page source for CP575 PDF URLs
                            var pageText = document.documentElement.outerHTML;
                            var pdfUrlMatches = pageText.match(/\/modein\/notices\/CP575_[^""\s]+\.pdf/g);
                            if (pdfUrlMatches && pdfUrlMatches.length > 0) {
                                var pdfUrl = pdfUrlMatches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'page_source' };
                            }
                            
                            // Method 4: Look for any PDF URL in the page
                            var allPdfMatches = pageText.match(/\/modein\/notices\/[^""\s]+\.pdf/g);
                            if (allPdfMatches && allPdfMatches.length > 0) {
                                var pdfUrl = allPdfMatches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'any_pdf' };
                            }
                            
                            return { success: false, error: 'No PDF URL found in page' };
                        } catch (e) {
                            return { success: false, error: e.message };
                        }
                    }
                    return extractDirectPdfUrl();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    if (jsResult.TryGetValue("success", out var success) && success is bool isSuccess && isSuccess)
                    {
                        if (jsResult.TryGetValue("url", out var url) && url is string pdfUrl)
                        {
                            var method = jsResult.TryGetValue("method", out var methodObj) ? methodObj?.ToString() : "unknown";
                            _logger.LogInformation("Successfully extracted PDF URL via {Method}: {Url}", method, pdfUrl);
                            
                            // Try to download the PDF directly
                            var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Successfully downloaded PDF via direct URL: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                            else
                            {
                                _logger.LogWarning("Failed to download PDF from extracted URL: {Url}", pdfUrl);
                            }
                        }
                    }
                    else if (jsResult.TryGetValue("error", out var error))
                    {
                        _logger.LogDebug("Failed to extract PDF URL: {Error}", error);
                    }
                }
                
                // Fallback: Try to construct the PDF URL based on the current page
                _logger.LogInformation("Attempting to construct PDF URL from page context");
                var currentUrl = Driver?.Url ?? "";
                var baseUrl = currentUrl.Substring(0, currentUrl.LastIndexOf('/'));
                
                // Try different PDF URL patterns
                var timestamp = DateTime.Now.Ticks;
                var urlPatterns = new[]
                {
                    $"{baseUrl}/modein/notices/CP575_{timestamp}.pdf",
                    $"{baseUrl}/notices/CP575_{timestamp}.pdf",
                    $"{baseUrl}/modein/CP575_{timestamp}.pdf"
                };
                
                foreach (var pattern in urlPatterns)
                {
                    _logger.LogInformation("Trying constructed PDF URL: {Url}", pattern);
                    
                    var pdfBytes = await DownloadPdfFromUrl(pattern, cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully downloaded PDF via constructed URL: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Direct PDF URL extraction failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryChromeDevToolsPdfCapture(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting Chrome DevTools PDF capture of current page");
                
                if (Driver is ChromeDriver chromeDriver)
                {
                    try
                    {
                        // Use the correct Chrome DevTools Protocol method
                        var printParams = new Dictionary<string, object>
                        {
                            ["landscape"] = false,
                            ["displayHeaderFooter"] = false,
                            ["printBackground"] = true,
                            ["preferCSSPageSize"] = true,
                            ["paperWidth"] = 8.27,
                            ["paperHeight"] = 11.69,
                            ["marginTop"] = 0.39,
                            ["marginBottom"] = 0.39,
                            ["marginLeft"] = 0.39,
                            ["marginRight"] = 0.39,
                            ["scale"] = 1.0
                        };
                        
                        var result = chromeDriver.ExecuteCdpCommand("Page.printToPDF", printParams);
                        
                        if (result is Dictionary<string, object> printResult &&
                            printResult.TryGetValue("data", out var base64Data))
                        {
                            var pdfBytes = Convert.FromBase64String(base64Data.ToString());
                            if (IsValidPdf(pdfBytes))
                            {
                                _logger.LogInformation("Successfully captured PDF via Chrome DevTools: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                            else
                            {
                                _logger.LogWarning("Chrome DevTools returned invalid PDF content");
                            }
                        }
                        else
                        {
                            _logger.LogWarning("Chrome DevTools PDF capture failed - no data returned");
                        }
                    }
                    catch (Exception cdpEx)
                    {
                        _logger.LogWarning("Chrome DevTools PDF capture failed: {Message}", cdpEx.Message);
                    }
                }
                else
                {
                    _logger.LogWarning("Driver is not ChromeDriver, cannot use DevTools Protocol");
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Chrome DevTools PDF capture failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryUltimateFallbackPdfDownload(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting ultimate fallback PDF download");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // Method 1: Extract all possible PDF URLs from the page
                var script = @"
                    function extractAllPdfUrls() {
                        var pdfUrls = [];
                        
                        // Extract from openPDFNoticeWindow functions
                        var openPdfLinks = document.querySelectorAll('a[onclick*=""openPDFNoticeWindow""]');
                        for (var i = 0; i < openPdfLinks.length; i++) {
                            var onclick = openPdfLinks[i].getAttribute('onclick');
                            if (onclick) {
                                var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                if (match && match[1]) {
                                    var url = match[1];
                                    if (url.startsWith('/')) {
                                        url = window.location.origin + url;
                                    }
                                    pdfUrls.push({ type: 'openPDFNoticeWindow', url: url });
                                }
                            }
                        }
                        
                        // Extract from href attributes with dynamic CP575 patterns
                        var hrefLinks = document.querySelectorAll('a[href*="".pdf""], a[href*=""CP575""]');
                        for (var i = 0; i < hrefLinks.length; i++) {
                            var href = hrefLinks[i].href;
                            if (href && (href.includes('.pdf') || href.includes('CP575'))) {
                                pdfUrls.push({ type: 'href', url: href });
                            }
                        }
                        
                        // Also look for any links containing CP575 in any format
                        var allLinks = document.querySelectorAll('a[href]');
                        for (var i = 0; i < allLinks.length; i++) {
                            var href = allLinks[i].href;
                            if (href && href.includes('CP575') && href.includes('.pdf')) {
                                pdfUrls.push({ type: 'cp575_dynamic', url: href });
                            }
                        }
                        
                        // Try to construct URL from page context
                        var currentUrl = window.location.href;
                        var baseUrl = window.location.origin;
                        
                        // Common PDF URL patterns with dynamic timestamps
                        var timestamp = Date.now();
                        var randomId = Math.random().toString(36).substring(2, 15);
                        var patterns = [
                            baseUrl + '/modein/notices/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + timestamp + '_' + randomId + '.pdf',
                            baseUrl + '/notices/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/CP575_' + timestamp + '.pdf',
                            baseUrl + '/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + randomId + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + timestamp + '_' + Date.now() + '.pdf'
                        ];
                        
                        return { pdfUrls: pdfUrls, patterns: patterns, baseUrl: baseUrl };
                    }
                    return extractAllPdfUrls();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    // Try each extracted URL
                    if (jsResult.TryGetValue("pdfUrls", out var pdfUrls) && pdfUrls is IEnumerable<object> urls)
                    {
                        foreach (var urlObj in urls)
                        {
                            if (urlObj is Dictionary<string, object> urlInfo)
                            {
                                if (urlInfo.TryGetValue("url", out var url) && url is string pdfUrl)
                                {
                                    _logger.LogInformation("Trying ultimate fallback URL: {Url}", pdfUrl);
                                    
                                    var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                                    if (pdfBytes != null && pdfBytes.Length > 0)
                                    {
                                        _logger.LogInformation("Ultimate fallback succeeded with URL: {Url}, Size: {FileSize} bytes", 
                                            pdfUrl, pdfBytes.Length);
                                        return pdfBytes;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Method 2: Try to construct URL from current page context
                    if (jsResult.TryGetValue("baseUrl", out var baseUrl) && baseUrl is string baseUrlStr)
                    {
                        var currentUrl = Driver?.Url ?? "";
                        var timestamp = DateTime.Now.Ticks;
                        
                        // Try different URL patterns with dynamic timestamps
                        var urlTimestamp = DateTime.Now.Ticks;
                        var randomId = Guid.NewGuid().ToString("N").Substring(0, 8);
                        var currentTime = DateTime.Now.Ticks;
                        
                        var urlPatterns = new[]
                        {
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}_{randomId}.pdf",
                            $"{baseUrlStr}/notices/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{randomId}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}_{currentTime}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{DateTimeOffset.Now.ToUnixTimeMilliseconds()}.pdf"
                        };
                        
                        foreach (var pattern in urlPatterns)
                        {
                            _logger.LogInformation("Trying constructed URL pattern: {Pattern}", pattern);
                            
                            var pdfBytes = await DownloadPdfFromUrl(pattern, cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Ultimate fallback succeeded with constructed URL: {Url}, Size: {FileSize} bytes", 
                                    pattern, pdfBytes.Length);
                                return pdfBytes;
                            }
                        }
                    }
                }
                
                // Method 3: Try to extract PDF URL from page source with dynamic patterns
                var pageSource = Driver?.PageSource ?? "";
                
                // Multiple regex patterns to catch different PDF URL formats
                var pdfUrlPatterns = new[]
                {
                    @"/modein/notices/CP575_\d+\.pdf",                    // Standard format
                    @"/modein/notices/CP575_\d+_\d+\.pdf",                // With additional timestamp
                    @"/modein/notices/CP575_[a-zA-Z0-9_]+\.pdf",          // Alphanumeric variations
                    @"/modein/notices/CP575_[a-zA-Z0-9_]+_[a-zA-Z0-9_]+\.pdf", // Multiple underscores
                    @"/notices/CP575_\d+\.pdf",                            // Without modein
                    @"/CP575_\d+\.pdf",                                    // Root level
                    @"/modein/CP575_\d+\.pdf",                             // Direct modein
                    @"/modein/notices/CP575_[^""\s]+\.pdf",                // Any characters except quotes/whitespace
                    @"/modein/notices/[^""\s]*CP575[^""\s]*\.pdf",         // CP575 anywhere in filename
                    @"/modein/notices/CP575_[a-zA-Z0-9_]{8,}\.pdf",       // At least 8 alphanumeric chars
                    @"/modein/notices/CP575_\d{10,}\.pdf",                 // At least 10 digits
                    @"/modein/notices/CP575_\d+[a-zA-Z0-9_]*\.pdf"        // Digits followed by optional chars
                };
                
                foreach (var pattern in pdfUrlPatterns)
                {
                    var pdfUrlMatches = Regex.Matches(pageSource, pattern);
                    
                    foreach (Match match in pdfUrlMatches)
                    {
                        var pdfUrl = match.Value;
                        if (pdfUrl.StartsWith("/"))
                        {
                            var baseUri = new Uri(Driver?.Url ?? "https://sa.www4.irs.gov");
                            pdfUrl = new Uri(baseUri, pdfUrl).ToString();
                        }
                        
                        _logger.LogInformation("Trying PDF URL from page source with pattern '{Pattern}': {Url}", pattern, pdfUrl);
                        
                        var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Ultimate fallback succeeded with page source URL: {Url}, Size: {FileSize} bytes", 
                                pdfUrl, pdfBytes.Length);
                            return pdfBytes;
                        }
                    }
                }
                
                // Method 4: Try to dynamically extract the actual PDF URL from the page
                _logger.LogInformation("Attempting to dynamically extract actual PDF URL from page");
                var dynamicPdfUrl = await TryExtractActualPdfUrlFromPage(cancellationToken);
                if (!string.IsNullOrEmpty(dynamicPdfUrl))
                {
                    _logger.LogInformation("Found actual PDF URL: {Url}", dynamicPdfUrl);
                    
                    var pdfBytes = await DownloadPdfFromUrl(dynamicPdfUrl, cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Ultimate fallback succeeded with actual PDF URL: {Url}, Size: {FileSize} bytes", 
                            dynamicPdfUrl, pdfBytes.Length);
                        return pdfBytes;
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Ultimate fallback PDF download failed: {Message}", ex.Message);
            }
            return null;
        }

        private Task<string?> TryExtractActualPdfUrlFromPage(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting to extract actual PDF URL from page");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // JavaScript to extract the actual PDF URL from the page
                var script = @"
                    function extractActualPdfUrl() {
                        try {
                            // Method 1: Look for the exact PDF link with openPDFNoticeWindow
                            var pdfLink = document.querySelector('a[onclick*=""openPDFNoticeWindow""]');
                            if (pdfLink) {
                                var onclick = pdfLink.getAttribute('onclick');
                                if (onclick) {
                                    var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                    if (match && match[1]) {
                                        var pdfUrl = match[1];
                                        if (pdfUrl.startsWith('/')) {
                                            pdfUrl = window.location.origin + pdfUrl;
                                        }
                                        return { success: true, url: pdfUrl, method: 'openPDFNoticeWindow' };
                                    }
                                }
                            }
                            
                            // Method 2: Look for any link with CP575 in href
                            var cp575Links = document.querySelectorAll('a[href*=""CP575""]');
                            for (var i = 0; i < cp575Links.length; i++) {
                                var href = cp575Links[i].href;
                                if (href && href.includes('CP575') && href.includes('.pdf')) {
                                    return { success: true, url: href, method: 'href_cp575' };
                                }
                            }
                            
                            // Method 3: Look for any link with .pdf extension
                            var pdfLinks = document.querySelectorAll('a[href*="".pdf""]');
                            for (var i = 0; i < pdfLinks.length; i++) {
                                var href = pdfLinks[i].href;
                                if (href && href.includes('.pdf')) {
                                    return { success: true, url: href, method: 'href_pdf' };
                                }
                            }
                            
                            // Method 4: Search in page source for PDF URLs
                            var pageText = document.documentElement.outerHTML;
                            var pdfUrlMatches = pageText.match(/\/modein\/notices\/CP575_[^""\s]+\.pdf/g);
                            if (pdfUrlMatches && pdfUrlMatches.length > 0) {
                                var pdfUrl = pdfUrlMatches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'page_source' };
                            }
                            
                            // Method 5: Look for any CP575 pattern in the page
                            var cp575Matches = pageText.match(/CP575_[^""\s]+\.pdf/g);
                            if (cp575Matches && cp575Matches.length > 0) {
                                var pdfUrl = '/modein/notices/' + cp575Matches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'cp575_pattern' };
                            }
                            
                            return { success: false, error: 'No PDF URL found' };
                        } catch (e) {
                            return { success: false, error: e.message };
                        }
                    }
                    return extractActualPdfUrl();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    if (jsResult.TryGetValue("success", out var success) && success is bool isSuccess && isSuccess)
                    {
                        if (jsResult.TryGetValue("url", out var url) && url is string pdfUrl)
                        {
                            var method = jsResult.TryGetValue("method", out var methodObj) ? methodObj?.ToString() : "unknown";
                            _logger.LogInformation("Successfully extracted actual PDF URL via {Method}: {Url}", method, pdfUrl);
                            return Task.FromResult<string?>(pdfUrl);
                        }
                    }
                    else if (jsResult.TryGetValue("error", out var error))
                    {
                        _logger.LogDebug("Failed to extract actual PDF URL: {Error}", error);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Actual PDF URL extraction failed: {Message}", ex.Message);
            }
            return Task.FromResult<string?>(null);
        }

        private async Task<byte[]?> TryCapturePdfFromBrowserViewer(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting comprehensive PDF capture from browser viewer");
                
                // Method 1: Check if we're already on a PDF page
                var currentUrl = Driver?.Url?.ToLower() ?? "";
                if (currentUrl.Contains(".pdf") || currentUrl.Contains("cp575"))
                {
                    _logger.LogInformation("Current page appears to be a PDF: {Url}", currentUrl);
                    
                    // Try all capture methods
                    var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully extracted PDF from current page: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryPrintToPdf(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully printed current page to PDF: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryCapturePdfFromPrintDialog(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully captured PDF from print dialog: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                }
                
                // Method 2: Search for PDF elements on the page
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                var script = @"
                    function findPdfElements() {
                        var pdfElements = [];
                        
                        // Look for PDF links
                        var links = document.querySelectorAll('a[href*="".pdf""], a[href*=""cp575""]');
                        for (var i = 0; i < links.length; i++) {
                            pdfElements.push({ type: 'link', href: links[i].href, text: links[i].textContent });
                        }
                        
                        // Look for PDF embeds
                        var embeds = document.querySelectorAll('embed[type=""application/pdf""]');
                        for (var i = 0; i < embeds.length; i++) {
                            pdfElements.push({ type: 'embed', src: embeds[i].src });
                        }
                        
                        // Look for PDF objects
                        var objects = document.querySelectorAll('object[type=""application/pdf""]');
                        for (var i = 0; i < objects.length; i++) {
                            pdfElements.push({ type: 'object', data: objects[i].data });
                        }
                        
                        // Look for iframes with PDFs
                        var iframes = document.querySelectorAll('iframe[src*="".pdf""]');
                        for (var i = 0; i < iframes.length; i++) {
                            pdfElements.push({ type: 'iframe', src: iframes[i].src });
                        }
                        
                        return pdfElements;
                    }
                    return findPdfElements();
                ";
                
                var pdfElements = jsExecutor?.ExecuteScript(script);
                if (pdfElements != null && pdfElements is IEnumerable<object> elements)
                {
                    foreach (var element in elements)
                    {
                        if (element is Dictionary<string, object> pdfElement)
                        {
                            var href = pdfElement.GetValueOrDefault("href")?.ToString();
                            var src = pdfElement.GetValueOrDefault("src")?.ToString();
                            var data = pdfElement.GetValueOrDefault("data")?.ToString();
                            
                            var url = href ?? src ?? data;
                            if (!string.IsNullOrEmpty(url))
                            {
                                _logger.LogInformation("Found PDF element: {Type}, URL: {Url}", 
                                    pdfElement.GetValueOrDefault("type"), url);
                                
                                var pdfBytes = await DownloadPdfFromUrl(url, cancellationToken);
                                if (pdfBytes != null && pdfBytes.Length > 0)
                                {
                                    _logger.LogInformation("Successfully downloaded PDF from element: {FileSize} bytes", pdfBytes.Length);
                                    return pdfBytes;
                                }
                            }
                        }
                    }
                }
                
                // Method 3: Try to trigger PDF download from any found elements
                var downloadSelectors = new[]
                {
                    "//a[contains(@href, '.pdf')]",
                    "//a[contains(@href, 'cp575')]",
                    "//button[contains(text(), 'Download')]",
                    "//button[contains(text(), 'View')]",
                    "//*[contains(text(), 'EIN Confirmation Letter')]",
                    "//*[contains(text(), 'confirmation letter')]"
                };
                
                foreach (var selector in downloadSelectors)
                {
                    try
                    {
                        var element = Driver?.FindElement(By.XPath(selector));
                        if (element != null && element.Displayed && element.Enabled)
                        {
                            _logger.LogInformation("Found PDF element with selector: {Selector}", selector);
                            
                            // Try clicking the element
                            element.Click();
                            await Task.Delay(3000, cancellationToken);
                            
                            // Check if a new window/tab opened
                            var newWindows = Driver?.WindowHandles.ToList();
                            var originalWindows = Driver?.WindowHandles.ToList();
                            
                            if (newWindows != null && newWindows.Count > originalWindows?.Count)
                            {
                                var newWindow = newWindows.FirstOrDefault(w => !originalWindows.Contains(w));
                                if (!string.IsNullOrEmpty(newWindow))
                                {
                                    Driver?.SwitchTo().Window(newWindow);
                                    await Task.Delay(2000, cancellationToken);
                                    
                                    var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                                    if (pdfBytes != null && pdfBytes.Length > 0)
                                    {
                                        _logger.LogInformation("Successfully captured PDF from new window: {FileSize} bytes", pdfBytes.Length);
                                        return pdfBytes;
                                    }
                                    
                                    // Close the new window and switch back
                                    Driver?.Close();
                                    Driver?.SwitchTo().Window(originalWindows.First());
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("PDF element selector {Selector} failed: {Message}", selector, ex.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Comprehensive PDF capture from browser viewer failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> DownloadPdfFromUrl(string? url, CancellationToken cancellationToken)
        {
            try
            {
                if (string.IsNullOrEmpty(url))
                {
                    return null;
                }

                _logger.LogInformation("Downloading PDF from URL: {Url}", url);

                // Get cookies from the current session
                var cookies = Driver?.Manage().Cookies.AllCookies;
                
                HttpClient httpClient;
                
                // Add cookies to HttpClient if available
                if (cookies != null && cookies.Count > 0)
                {
                    var cookieContainer = new CookieContainer();
                    foreach (var cookie in cookies)
                    {
                        try
                        {
                            cookieContainer.Add(new System.Net.Cookie(cookie.Name, cookie.Value, cookie.Path, cookie.Domain));
                        }
                        catch (Exception cookieEx)
                        {
                            _logger.LogDebug("Failed to add cookie {CookieName}: {Message}", cookie.Name, cookieEx.Message);
                        }
                    }
                    
                    var handler = new HttpClientHandler() { CookieContainer = cookieContainer };
                    httpClient = new HttpClient(handler);
                }
                else
                {
                    httpClient = new HttpClient();
                }
                
                using (httpClient)
                {
                    // Set appropriate headers
                    httpClient.DefaultRequestHeaders.Add("User-Agent", 
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
                    httpClient.DefaultRequestHeaders.Add("Accept", "application/pdf,*/*");
                    httpClient.DefaultRequestHeaders.Add("Referer", Driver?.Url);

                    httpClient.Timeout = TimeSpan.FromSeconds(30);
                    var response = await httpClient.GetAsync(url, cancellationToken);
                    
                    if (response.IsSuccessStatusCode)
                    {
                        var content = await response.Content.ReadAsByteArrayAsync(cancellationToken);
                        if (IsValidPdf(content))
                        {
                            _logger.LogInformation("PDF download successful: {FileSize} bytes", content.Length);
                            return content;
                        }
                        else
                        {
                            _logger.LogWarning("Download returned non-PDF content");
                        }
                    }
                    else
                    {
                        _logger.LogWarning("PDF download failed with status: {StatusCode}", response.StatusCode);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF download from URL failed: {Message}", ex.Message);
            }

            return null;
        }

        private async Task<byte[]?> TryDirectDownload(IWebElement pdfLinkElement, CancellationToken cancellationToken)
        {
            try
            {
                var href = pdfLinkElement.GetAttribute("href");
                if (string.IsNullOrEmpty(href))
                {
                    _logger.LogDebug("No href attribute found on PDF link");
                    return null;
                }

                _logger.LogInformation("Attempting direct download from URL: {Url}", href);

                // Get cookies from the current session
                var cookies = Driver?.Manage().Cookies.AllCookies;
                
                HttpClient httpClient;
                
                // Add cookies to HttpClient if available
                if (cookies != null && cookies.Count > 0)
                {
                    var cookieContainer = new CookieContainer();
                    foreach (var cookie in cookies)
                    {
                        try
                        {
                            cookieContainer.Add(new System.Net.Cookie(cookie.Name, cookie.Value, cookie.Path, cookie.Domain));
                        }
                        catch (Exception cookieEx)
                        {
                            _logger.LogDebug("Failed to add cookie {CookieName}: {Message}", cookie.Name, cookieEx.Message);
                        }
                    }
                }
                else
                {
                    httpClient = new HttpClient();
                }
                
                using (httpClient)
                {
                    // Set appropriate headers
                    httpClient.DefaultRequestHeaders.Add("User-Agent", 
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
                    httpClient.DefaultRequestHeaders.Add("Accept", "application/pdf,*/*");
                    httpClient.DefaultRequestHeaders.Add("Referer", Driver?.Url);

                    httpClient.Timeout = TimeSpan.FromSeconds(30);
                    var response = await httpClient.GetAsync(href, cancellationToken);
                    
                    if (response.IsSuccessStatusCode)
                    {
                        var content = await response.Content.ReadAsByteArrayAsync(cancellationToken);
                        if (IsValidPdf(content))
                        {
                            _logger.LogInformation("PDF download successful: {FileSize} bytes", content.Length);
                            return content;
                        }
                        else
                        {
                            _logger.LogWarning("Download returned non-PDF content");
                        }
                    }
                    else
                    {
                        _logger.LogWarning("PDF download failed with status: {StatusCode}", response.StatusCode);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF download from URL failed: {Message}", ex.Message);
            }

            return null;
        }

        private async Task<byte[]?> TryChromeDevToolsPdfCapture(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting Chrome DevTools PDF capture of current page");
                
                if (Driver is ChromeDriver chromeDriver)
                {
                    try
                    {
                        // Use the correct Chrome DevTools Protocol method
                        var printParams = new Dictionary<string, object>
                        {
                            ["landscape"] = false,
                            ["displayHeaderFooter"] = false,
                            ["printBackground"] = true,
                            ["preferCSSPageSize"] = true,
                            ["paperWidth"] = 8.27,
                            ["paperHeight"] = 11.69,
                            ["marginTop"] = 0.39,
                            ["marginBottom"] = 0.39,
                            ["marginLeft"] = 0.39,
                            ["marginRight"] = 0.39,
                            ["scale"] = 1.0
                        };
                        
                        var result = chromeDriver.ExecuteCdpCommand("Page.printToPDF", printParams);
                        
                        if (result is Dictionary<string, object> printResult &&
                            printResult.TryGetValue("data", out var base64Data))
                        {
                            var pdfBytes = Convert.FromBase64String(base64Data.ToString());
                            if (IsValidPdf(pdfBytes))
                            {
                                _logger.LogInformation("Successfully captured PDF via Chrome DevTools: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                            else
                            {
                                _logger.LogWarning("Chrome DevTools returned invalid PDF content");
                            }
                        }
                        else
                        {
                            _logger.LogWarning("Chrome DevTools PDF capture failed - no data returned");
                        }
                    }
                    catch (Exception cdpEx)
                    {
                        _logger.LogWarning("Chrome DevTools PDF capture failed: {Message}", cdpEx.Message);
                    }
                }
                else
                {
                    _logger.LogWarning("Driver is not ChromeDriver, cannot use DevTools Protocol");
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Chrome DevTools PDF capture failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryUltimateFallbackPdfDownload(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting ultimate fallback PDF download");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // Method 1: Extract all possible PDF URLs from the page
                var script = @"
                    function extractAllPdfUrls() {
                        var pdfUrls = [];
                        
                        // Extract from openPDFNoticeWindow functions
                        var openPdfLinks = document.querySelectorAll('a[onclick*=""openPDFNoticeWindow""]');
                        for (var i = 0; i < openPdfLinks.length; i++) {
                            var onclick = openPdfLinks[i].getAttribute('onclick');
                            if (onclick) {
                                var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                if (match && match[1]) {
                                    var url = match[1];
                                    if (url.startsWith('/')) {
                                        url = window.location.origin + url;
                                    }
                                    pdfUrls.push({ type: 'openPDFNoticeWindow', url: url });
                                }
                            }
                        }
                        
                        // Extract from href attributes with dynamic CP575 patterns
                        var hrefLinks = document.querySelectorAll('a[href*="".pdf""], a[href*=""CP575""]');
                        for (var i = 0; i < hrefLinks.length; i++) {
                            var href = hrefLinks[i].href;
                            if (href && (href.includes('.pdf') || href.includes('CP575'))) {
                                pdfUrls.push({ type: 'href', url: href });
                            }
                        }
                        
                        // Also look for any links containing CP575 in any format
                        var allLinks = document.querySelectorAll('a[href]');
                        for (var i = 0; i < allLinks.length; i++) {
                            var href = allLinks[i].href;
                            if (href && href.includes('CP575') && href.includes('.pdf')) {
                                pdfUrls.push({ type: 'cp575_dynamic', url: href });
                            }
                        }
                        
                        // Try to construct URL from page context
                        var currentUrl = window.location.href;
                        var baseUrl = window.location.origin;
                        
                        // Common PDF URL patterns with dynamic timestamps
                        var timestamp = Date.now();
                        var randomId = Math.random().toString(36).substring(2, 15);
                        var patterns = [
                            baseUrl + '/modein/notices/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + timestamp + '_' + randomId + '.pdf',
                            baseUrl + '/notices/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/CP575_' + timestamp + '.pdf',
                            baseUrl + '/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + randomId + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + timestamp + '_' + Date.now() + '.pdf'
                        ];
                        
                        return { pdfUrls: pdfUrls, patterns: patterns, baseUrl: baseUrl };
                    }
                    return extractAllPdfUrls();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    // Try each extracted URL
                    if (jsResult.TryGetValue("pdfUrls", out var pdfUrls) && pdfUrls is IEnumerable<object> urls)
                    {
                        foreach (var urlObj in urls)
                        {
                            if (urlObj is Dictionary<string, object> urlInfo)
                            {
                                if (urlInfo.TryGetValue("url", out var url) && url is string pdfUrl)
                                {
                                    _logger.LogInformation("Trying ultimate fallback URL: {Url}", pdfUrl);
                                    
                                    var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                                    if (pdfBytes != null && pdfBytes.Length > 0)
                                    {
                                        _logger.LogInformation("Ultimate fallback succeeded with URL: {Url}, Size: {FileSize} bytes", 
                                            pdfUrl, pdfBytes.Length);
                                        return pdfBytes;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Method 2: Try to construct URL from current page context
                    if (jsResult.TryGetValue("baseUrl", out var baseUrl) && baseUrl is string baseUrlStr)
                    {
                        var currentUrl = Driver?.Url ?? "";
                        var timestamp = DateTime.Now.Ticks;
                        
                        // Try different URL patterns with dynamic timestamps
                        var urlTimestamp = DateTime.Now.Ticks;
                        var randomId = Guid.NewGuid().ToString("N").Substring(0, 8);
                        var currentTime = DateTime.Now.Ticks;
                        
                        var urlPatterns = new[]
                        {
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}_{randomId}.pdf",
                            $"{baseUrlStr}/notices/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{randomId}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}_{currentTime}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{DateTimeOffset.Now.ToUnixTimeMilliseconds()}.pdf"
                        };
                        
                        foreach (var pattern in urlPatterns)
                        {
                            _logger.LogInformation("Trying constructed URL pattern: {Pattern}", pattern);
                            
                            var pdfBytes = await DownloadPdfFromUrl(pattern, cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Ultimate fallback succeeded with constructed URL: {Url}, Size: {FileSize} bytes", 
                                    pattern, pdfBytes.Length);
                                return pdfBytes;
                            }
                        }
                    }
                }
                
                // Method 3: Try to extract PDF URL from page source with dynamic patterns
                var pageSource = Driver?.PageSource ?? "";
                
                // Multiple regex patterns to catch different PDF URL formats
                var pdfUrlPatterns = new[]
                {
                    @"/modein/notices/CP575_\d+\.pdf",                    // Standard format
                    @"/modein/notices/CP575_\d+_\d+\.pdf",                // With additional timestamp
                    @"/modein/notices/CP575_[a-zA-Z0-9_]+\.pdf",          // Alphanumeric variations
                    @"/modein/notices/CP575_[a-zA-Z0-9_]+_[a-zA-Z0-9_]+\.pdf", // Multiple underscores
                    @"/notices/CP575_\d+\.pdf",                            // Without modein
                    @"/CP575_\d+\.pdf",                                    // Root level
                    @"/modein/CP575_\d+\.pdf",                             // Direct modein
                    @"/modein/notices/CP575_[^""\s]+\.pdf",                // Any characters except quotes/whitespace
                    @"/modein/notices/[^""\s]*CP575[^""\s]*\.pdf",         // CP575 anywhere in filename
                    @"/modein/notices/CP575_[a-zA-Z0-9_]{8,}\.pdf",       // At least 8 alphanumeric chars
                    @"/modein/notices/CP575_\d{10,}\.pdf",                 // At least 10 digits
                    @"/modein/notices/CP575_\d+[a-zA-Z0-9_]*\.pdf"        // Digits followed by optional chars
                };
                
                foreach (var pattern in pdfUrlPatterns)
                {
                    var pdfUrlMatches = Regex.Matches(pageSource, pattern);
                    
                    foreach (Match match in pdfUrlMatches)
                    {
                        var pdfUrl = match.Value;
                        if (pdfUrl.StartsWith("/"))
                        {
                            var baseUri = new Uri(Driver?.Url ?? "https://sa.www4.irs.gov");
                            pdfUrl = new Uri(baseUri, pdfUrl).ToString();
                        }
                        
                        _logger.LogInformation("Trying PDF URL from page source with pattern '{Pattern}': {Url}", pattern, pdfUrl);
                        
                        var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Ultimate fallback succeeded with page source URL: {Url}, Size: {FileSize} bytes", 
                                pdfUrl, pdfBytes.Length);
                            return pdfBytes;
                        }
                    }
                }
                
                // Method 4: Try to dynamically extract the actual PDF URL from the page
                _logger.LogInformation("Attempting to dynamically extract actual PDF URL from page");
                var dynamicPdfUrl = await TryExtractActualPdfUrlFromPage(cancellationToken);
                if (!string.IsNullOrEmpty(dynamicPdfUrl))
                {
                    _logger.LogInformation("Found actual PDF URL: {Url}", dynamicPdfUrl);
                    
                    var pdfBytes = await DownloadPdfFromUrl(dynamicPdfUrl, cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Ultimate fallback succeeded with actual PDF URL: {Url}, Size: {FileSize} bytes", 
                            dynamicPdfUrl, pdfBytes.Length);
                        return pdfBytes;
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Ultimate fallback PDF download failed: {Message}", ex.Message);
            }
            return null;
        }

        private Task<string?> TryExtractActualPdfUrlFromPage(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting to extract actual PDF URL from page");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // JavaScript to extract the actual PDF URL from the page
                var script = @"
                    function extractActualPdfUrl() {
                        try {
                            // Method 1: Look for the exact PDF link with openPDFNoticeWindow
                            var pdfLink = document.querySelector('a[onclick*=""openPDFNoticeWindow""]');
                            if (pdfLink) {
                                var onclick = pdfLink.getAttribute('onclick');
                                if (onclick) {
                                    var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                    if (match && match[1]) {
                                        var pdfUrl = match[1];
                                        if (pdfUrl.startsWith('/')) {
                                            pdfUrl = window.location.origin + pdfUrl;
                                        }
                                        return { success: true, url: pdfUrl, method: 'openPDFNoticeWindow' };
                                    }
                                }
                            }
                            
                            // Method 2: Look for any link with CP575 in href
                            var cp575Links = document.querySelectorAll('a[href*=""CP575""]');
                            for (var i = 0; i < cp575Links.length; i++) {
                                var href = cp575Links[i].href;
                                if (href && href.includes('CP575') && href.includes('.pdf')) {
                                    return { success: true, url: href, method: 'href_cp575' };
                                }
                            }
                            
                            // Method 3: Look for any link with .pdf extension
                            var pdfLinks = document.querySelectorAll('a[href*="".pdf""]');
                            for (var i = 0; i < pdfLinks.length; i++) {
                                var href = pdfLinks[i].href;
                                if (href && href.includes('.pdf')) {
                                    return { success: true, url: href, method: 'href_pdf' };
                                }
                            }
                            
                            // Method 4: Search in page source for PDF URLs
                            var pageText = document.documentElement.outerHTML;
                            var pdfUrlMatches = pageText.match(/\/modein\/notices\/CP575_[^""\s]+\.pdf/g);
                            if (pdfUrlMatches && pdfUrlMatches.length > 0) {
                                var pdfUrl = pdfUrlMatches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'page_source' };
                            }
                            
                            // Method 5: Look for any CP575 pattern in the page
                            var cp575Matches = pageText.match(/CP575_[^""\s]+\.pdf/g);
                            if (cp575Matches && cp575Matches.length > 0) {
                                var pdfUrl = '/modein/notices/' + cp575Matches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'cp575_pattern' };
                            }
                            
                            return { success: false, error: 'No PDF URL found' };
                        } catch (e) {
                            return { success: false, error: e.message };
                        }
                    }
                    return extractActualPdfUrl();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    if (jsResult.TryGetValue("success", out var success) && success is bool isSuccess && isSuccess)
                    {
                        if (jsResult.TryGetValue("url", out var url) && url is string pdfUrl)
                        {
                            var method = jsResult.TryGetValue("method", out var methodObj) ? methodObj?.ToString() : "unknown";
                            _logger.LogInformation("Successfully extracted actual PDF URL via {Method}: {Url}", method, pdfUrl);
                            return Task.FromResult<string?>(pdfUrl);
                        }
                    }
                    else if (jsResult.TryGetValue("error", out var error))
                    {
                        _logger.LogDebug("Failed to extract actual PDF URL: {Error}", error);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Actual PDF URL extraction failed: {Message}", ex.Message);
            }
            return Task.FromResult<string?>(null);
        }

        private async Task<byte[]?> TryCapturePdfFromBrowserViewer(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting comprehensive PDF capture from browser viewer");
                
                // Method 1: Check if we're already on a PDF page
                var currentUrl = Driver?.Url?.ToLower() ?? "";
                if (currentUrl.Contains(".pdf") || currentUrl.Contains("cp575"))
                {
                    _logger.LogInformation("Current page appears to be a PDF: {Url}", currentUrl);
                    
                    // Try all capture methods
                    var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully extracted PDF from current page: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryPrintToPdf(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully printed current page to PDF: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryCapturePdfFromPrintDialog(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully captured PDF from print dialog: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                }
                
                // Method 2: Search for PDF elements on the page
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                var script = @"
                    function findPdfElements() {
                        var pdfElements = [];
                        
                        // Look for PDF links
                        var links = document.querySelectorAll('a[href*="".pdf""], a[href*=""cp575""]');
                        for (var i = 0; i < links.length; i++) {
                            pdfElements.push({ type: 'link', href: links[i].href, text: links[i].textContent });
                        }
                        
                        // Look for PDF embeds
                        var embeds = document.querySelectorAll('embed[type=""application/pdf""]');
                        for (var i = 0; i < embeds.length; i++) {
                            pdfElements.push({ type: 'embed', src: embeds[i].src });
                        }
                        
                        // Look for PDF objects
                        var objects = document.querySelectorAll('object[type=""application/pdf""]');
                        for (var i = 0; i < objects.length; i++) {
                            pdfElements.push({ type: 'object', data: objects[i].data });
                        }
                        
                        // Look for iframes with PDFs
                        var iframes = document.querySelectorAll('iframe[src*="".pdf""]');
                        for (var i = 0; i < iframes.length; i++) {
                            pdfElements.push({ type: 'iframe', src: iframes[i].src });
                        }
                        
                        return pdfElements;
                    }
                    return findPdfElements();
                ";
                
                var pdfElements = jsExecutor?.ExecuteScript(script);
                if (pdfElements != null && pdfElements is IEnumerable<object> elements)
                {
                    foreach (var element in elements)
                    {
                        if (element is Dictionary<string, object> pdfElement)
                        {
                            var href = pdfElement.GetValueOrDefault("href")?.ToString();
                            var src = pdfElement.GetValueOrDefault("src")?.ToString();
                            var data = pdfElement.GetValueOrDefault("data")?.ToString();
                            
                            var url = href ?? src ?? data;
                            if (!string.IsNullOrEmpty(url))
                            {
                                _logger.LogInformation("Found PDF element: {Type}, URL: {Url}", 
                                    pdfElement.GetValueOrDefault("type"), url);
                                
                                var pdfBytes = await DownloadPdfFromUrl(url, cancellationToken);
                                if (pdfBytes != null && pdfBytes.Length > 0)
                                {
                                    _logger.LogInformation("Successfully downloaded PDF from element: {FileSize} bytes", pdfBytes.Length);
                                    return pdfBytes;
                                }
                            }
                        }
                    }
                }
                
                // Method 3: Try to trigger PDF download from any found elements
                var downloadSelectors = new[]
                {
                    "//a[contains(@href, '.pdf')]",
                    "//a[contains(@href, 'cp575')]",
                    "//button[contains(text(), 'Download')]",
                    "//button[contains(text(), 'View')]",
                    "//*[contains(text(), 'EIN Confirmation Letter')]",
                    "//*[contains(text(), 'confirmation letter')]"
                };
                
                foreach (var selector in downloadSelectors)
                {
                    try
                    {
                        var element = Driver?.FindElement(By.XPath(selector));
                        if (element != null && element.Displayed && element.Enabled)
                        {
                            _logger.LogInformation("Found PDF element with selector: {Selector}", selector);
                            
                            // Try clicking the element
                            element.Click();
                            await Task.Delay(3000, cancellationToken);
                            
                            // Check if a new window/tab opened
                            var newWindows = Driver?.WindowHandles.ToList();
                            var originalWindows = Driver?.WindowHandles.ToList();
                            
                            if (newWindows != null && newWindows.Count > originalWindows?.Count)
                            {
                                var newWindow = newWindows.FirstOrDefault(w => !originalWindows.Contains(w));
                                if (!string.IsNullOrEmpty(newWindow))
                                {
                                    Driver?.SwitchTo().Window(newWindow);
                                    await Task.Delay(2000, cancellationToken);
                                    
                                    var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                                    if (pdfBytes != null && pdfBytes.Length > 0)
                                    {
                                        _logger.LogInformation("Successfully captured PDF from new window: {FileSize} bytes", pdfBytes.Length);
                                        return pdfBytes;
                                    }
                                    
                                    // Close the new window and switch back
                                    Driver?.Close();
                                    Driver?.SwitchTo().Window(originalWindows.First());
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("PDF element selector {Selector} failed: {Message}", selector, ex.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Comprehensive PDF capture from browser viewer failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> DownloadPdfFromUrl(string? url, CancellationToken cancellationToken)
        {
            try
            {
                if (string.IsNullOrEmpty(url))
                {
                    return null;
                }

                _logger.LogInformation("Downloading PDF from URL: {Url}", url);

                // Get cookies from the current session
                var cookies = Driver?.Manage().Cookies.AllCookies;
                
                HttpClient httpClient;
                
                // Add cookies to HttpClient if available
                if (cookies != null && cookies.Count > 0)
                {
                    var cookieContainer = new CookieContainer();
                    foreach (var cookie in cookies)
                    {
                        try
                        {
                            cookieContainer.Add(new System.Net.Cookie(cookie.Name, cookie.Value, cookie.Path, cookie.Domain));
                        }
                        catch (Exception cookieEx)
                        {
                            _logger.LogDebug("Failed to add cookie {CookieName}: {Message}", cookie.Name, cookieEx.Message);
                        }
                    }
                    
                    var handler = new HttpClientHandler() { CookieContainer = cookieContainer };
                    httpClient = new HttpClient(handler);
                }
                else
                {
                    httpClient = new HttpClient();
                }
                
                using (httpClient)
                {
                    // Set appropriate headers
                    httpClient.DefaultRequestHeaders.Add("User-Agent", 
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
                    httpClient.DefaultRequestHeaders.Add("Accept", "application/pdf,*/*");
                    httpClient.DefaultRequestHeaders.Add("Referer", Driver?.Url);

                    httpClient.Timeout = TimeSpan.FromSeconds(30);
                    var response = await httpClient.GetAsync(url, cancellationToken);
                    
                    if (response.IsSuccessStatusCode)
                    {
                        var content = await response.Content.ReadAsByteArrayAsync(cancellationToken);
                        if (IsValidPdf(content))
                        {
                            _logger.LogInformation("PDF download successful: {FileSize} bytes", content.Length);
                            return content;
                        }
                        else
                        {
                            _logger.LogWarning("Download returned non-PDF content");
                        }
                    }
                    else
                    {
                        _logger.LogWarning("PDF download failed with status: {StatusCode}", response.StatusCode);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF download from URL failed: {Message}", ex.Message);
            }

            return null;
        }

        private async Task<byte[]?> TryDirectDownload(IWebElement pdfLinkElement, CancellationToken cancellationToken)
        {
            try
            {
                var href = pdfLinkElement.GetAttribute("href");
                if (string.IsNullOrEmpty(href))
                {
                    _logger.LogDebug("No href attribute found on PDF link");
                    return null;
                }

                _logger.LogInformation("Attempting direct download from URL: {Url}", href);

                // Get cookies from the current session
                var cookies = Driver?.Manage().Cookies.AllCookies;
                
                HttpClient httpClient;
                
                // Add cookies to HttpClient if available
                if (cookies != null && cookies.Count > 0)
                {
                    var cookieContainer = new CookieContainer();
                    foreach (var cookie in cookies)
                    {
                        try
                        {
                            cookieContainer.Add(new System.Net.Cookie(cookie.Name, cookie.Value, cookie.Path, cookie.Domain));
                        }
                        catch (Exception cookieEx)
                        {
                            _logger.LogDebug("Failed to add cookie {CookieName}: {Message}", cookie.Name, cookieEx.Message);
                        }
                    }
                }
                else
                {
                    httpClient = new HttpClient();
                }
                
                using (httpClient)
                {
                    // Set appropriate headers
                    httpClient.DefaultRequestHeaders.Add("User-Agent", 
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
                    httpClient.DefaultRequestHeaders.Add("Accept", "application/pdf,*/*");
                    httpClient.DefaultRequestHeaders.Add("Referer", Driver?.Url);

                    httpClient.Timeout = TimeSpan.FromSeconds(30);
                    var response = await httpClient.GetAsync(href, cancellationToken);
                    
                    if (response.IsSuccessStatusCode)
                    {
                        var content = await response.Content.ReadAsByteArrayAsync(cancellationToken);
                        if (IsValidPdf(content))
                        {
                            _logger.LogInformation("PDF download successful: {FileSize} bytes", content.Length);
                            return content;
                        }
                        else
                        {
                            _logger.LogWarning("Download returned non-PDF content");
                        }
                    }
                    else
                    {
                        _logger.LogWarning("PDF download failed with status: {StatusCode}", response.StatusCode);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF download from URL failed: {Message}", ex.Message);
            }

            return null;
        }

        private async Task<byte[]?> TryChromeDevToolsPdfCapture(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting Chrome DevTools PDF capture of current page");
                
                if (Driver is ChromeDriver chromeDriver)
                {
                    try
                    {
                        // Use the correct Chrome DevTools Protocol method
                        var printParams = new Dictionary<string, object>
                        {
                            ["landscape"] = false,
                            ["displayHeaderFooter"] = false,
                            ["printBackground"] = true,
                            ["preferCSSPageSize"] = true,
                            ["paperWidth"] = 8.27,
                            ["paperHeight"] = 11.69,
                            ["marginTop"] = 0.39,
                            ["marginBottom"] = 0.39,
                            ["marginLeft"] = 0.39,
                            ["marginRight"] = 0.39,
                            ["scale"] = 1.0
                        };
                        
                        var result = chromeDriver.ExecuteCdpCommand("Page.printToPDF", printParams);
                        
                        if (result is Dictionary<string, object> printResult &&
                            printResult.TryGetValue("data", out var base64Data))
                        {
                            var pdfBytes = Convert.FromBase64String(base64Data.ToString());
                            if (IsValidPdf(pdfBytes))
                            {
                                _logger.LogInformation("Successfully captured PDF via Chrome DevTools: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                            else
                            {
                                _logger.LogWarning("Chrome DevTools returned invalid PDF content");
                            }
                        }
                        else
                        {
                            _logger.LogWarning("Chrome DevTools PDF capture failed - no data returned");
                        }
                    }
                    catch (Exception cdpEx)
                    {
                        _logger.LogWarning("Chrome DevTools PDF capture failed: {Message}", cdpEx.Message);
                    }
                }
                else
                {
                    _logger.LogWarning("Driver is not ChromeDriver, cannot use DevTools Protocol");
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Chrome DevTools PDF capture failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryUltimateFallbackPdfDownload(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting ultimate fallback PDF download");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // Method 1: Extract all possible PDF URLs from the page
                var script = @"
                    function extractAllPdfUrls() {
                        var pdfUrls = [];
                        
                        // Extract from openPDFNoticeWindow functions
                        var openPdfLinks = document.querySelectorAll('a[onclick*=""openPDFNoticeWindow""]');
                        for (var i = 0; i < openPdfLinks.length; i++) {
                            var onclick = openPdfLinks[i].getAttribute('onclick');
                            if (onclick) {
                                var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                if (match && match[1]) {
                                    var url = match[1];
                                    if (url.startsWith('/')) {
                                        url = window.location.origin + url;
                                    }
                                    pdfUrls.push({ type: 'openPDFNoticeWindow', url: url });
                                }
                            }
                        }
                        
                        // Extract from href attributes with dynamic CP575 patterns
                        var hrefLinks = document.querySelectorAll('a[href*="".pdf""], a[href*=""CP575""]');
                        for (var i = 0; i < hrefLinks.length; i++) {
                            var href = hrefLinks[i].href;
                            if (href && (href.includes('.pdf') || href.includes('CP575'))) {
                                pdfUrls.push({ type: 'href', url: href });
                            }
                        }
                        
                        // Also look for any links containing CP575 in any format
                        var allLinks = document.querySelectorAll('a[href]');
                        for (var i = 0; i < allLinks.length; i++) {
                            var href = allLinks[i].href;
                            if (href && href.includes('CP575') && href.includes('.pdf')) {
                                pdfUrls.push({ type: 'cp575_dynamic', url: href });
                            }
                        }
                        
                        // Try to construct URL from page context
                        var currentUrl = window.location.href;
                        var baseUrl = window.location.origin;
                        
                        // Common PDF URL patterns with dynamic timestamps
                        var timestamp = Date.now();
                        var randomId = Math.random().toString(36).substring(2, 15);
                        var patterns = [
                            baseUrl + '/modein/notices/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + timestamp + '_' + randomId + '.pdf',
                            baseUrl + '/notices/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/CP575_' + timestamp + '.pdf',
                            baseUrl + '/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + randomId + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + timestamp + '_' + Date.now() + '.pdf'
                        ];
                        
                        return { pdfUrls: pdfUrls, patterns: patterns, baseUrl: baseUrl };
                    }
                    return extractAllPdfUrls();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    // Try each extracted URL
                    if (jsResult.TryGetValue("pdfUrls", out var pdfUrls) && pdfUrls is IEnumerable<object> urls)
                    {
                        foreach (var urlObj in urls)
                        {
                            if (urlObj is Dictionary<string, object> urlInfo)
                            {
                                if (urlInfo.TryGetValue("url", out var url) && url is string pdfUrl)
                                {
                                    _logger.LogInformation("Trying ultimate fallback URL: {Url}", pdfUrl);
                                    
                                    var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                                    if (pdfBytes != null && pdfBytes.Length > 0)
                                    {
                                        _logger.LogInformation("Ultimate fallback succeeded with URL: {Url}, Size: {FileSize} bytes", 
                                            pdfUrl, pdfBytes.Length);
                                        return pdfBytes;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Method 2: Try to construct URL from current page context
                    if (jsResult.TryGetValue("baseUrl", out var baseUrl) && baseUrl is string baseUrlStr)
                    {
                        var currentUrl = Driver?.Url ?? "";
                        var timestamp = DateTime.Now.Ticks;
                        
                        // Try different URL patterns with dynamic timestamps
                        var urlTimestamp = DateTime.Now.Ticks;
                        var randomId = Guid.NewGuid().ToString("N").Substring(0, 8);
                        var currentTime = DateTime.Now.Ticks;
                        
                        var urlPatterns = new[]
                        {
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}_{randomId}.pdf",
                            $"{baseUrlStr}/notices/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{randomId}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}_{currentTime}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{DateTimeOffset.Now.ToUnixTimeMilliseconds()}.pdf"
                        };
                        
                        foreach (var pattern in urlPatterns)
                        {
                            _logger.LogInformation("Trying constructed URL pattern: {Pattern}", pattern);
                            
                            var pdfBytes = await DownloadPdfFromUrl(pattern, cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Ultimate fallback succeeded with constructed URL: {Url}, Size: {FileSize} bytes", 
                                    pattern, pdfBytes.Length);
                                return pdfBytes;
                            }
                        }
                    }
                }
                
                // Method 3: Try to extract PDF URL from page source with dynamic patterns
                var pageSource = Driver?.PageSource ?? "";
                
                // Multiple regex patterns to catch different PDF URL formats
                var pdfUrlPatterns = new[]
                {
                    @"/modein/notices/CP575_\d+\.pdf",                    // Standard format
                    @"/modein/notices/CP575_\d+_\d+\.pdf",                // With additional timestamp
                    @"/modein/notices/CP575_[a-zA-Z0-9_]+\.pdf",          // Alphanumeric variations
                    @"/modein/notices/CP575_[a-zA-Z0-9_]+_[a-zA-Z0-9_]+\.pdf", // Multiple underscores
                    @"/notices/CP575_\d+\.pdf",                            // Without modein
                    @"/CP575_\d+\.pdf",                                    // Root level
                    @"/modein/CP575_\d+\.pdf",                             // Direct modein
                    @"/modein/notices/CP575_[^""\s]+\.pdf",                // Any characters except quotes/whitespace
                    @"/modein/notices/[^""\s]*CP575[^""\s]*\.pdf",         // CP575 anywhere in filename
                    @"/modein/notices/CP575_[a-zA-Z0-9_]{8,}\.pdf",       // At least 8 alphanumeric chars
                    @"/modein/notices/CP575_\d{10,}\.pdf",                 // At least 10 digits
                    @"/modein/notices/CP575_\d+[a-zA-Z0-9_]*\.pdf"        // Digits followed by optional chars
                };
                
                foreach (var pattern in pdfUrlPatterns)
                {
                    var pdfUrlMatches = Regex.Matches(pageSource, pattern);
                    
                    foreach (Match match in pdfUrlMatches)
                    {
                        var pdfUrl = match.Value;
                        if (pdfUrl.StartsWith("/"))
                        {
                            var baseUri = new Uri(Driver?.Url ?? "https://sa.www4.irs.gov");
                            pdfUrl = new Uri(baseUri, pdfUrl).ToString();
                        }
                        
                        _logger.LogInformation("Trying PDF URL from page source with pattern '{Pattern}': {Url}", pattern, pdfUrl);
                        
                        var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Ultimate fallback succeeded with page source URL: {Url}, Size: {FileSize} bytes", 
                                pdfUrl, pdfBytes.Length);
                            return pdfBytes;
                        }
                    }
                }
                
                // Method 4: Try to dynamically extract the actual PDF URL from the page
                _logger.LogInformation("Attempting to dynamically extract actual PDF URL from page");
                var dynamicPdfUrl = await TryExtractActualPdfUrlFromPage(cancellationToken);
                if (!string.IsNullOrEmpty(dynamicPdfUrl))
                {
                    _logger.LogInformation("Found actual PDF URL: {Url}", dynamicPdfUrl);
                    
                    var pdfBytes = await DownloadPdfFromUrl(dynamicPdfUrl, cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Ultimate fallback succeeded with actual PDF URL: {Url}, Size: {FileSize} bytes", 
                            dynamicPdfUrl, pdfBytes.Length);
                        return pdfBytes;
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Ultimate fallback PDF download failed: {Message}", ex.Message);
            }
            return null;
        }

        private Task<string?> TryExtractActualPdfUrlFromPage(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting to extract actual PDF URL from page");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // JavaScript to extract the actual PDF URL from the page
                var script = @"
                    function extractActualPdfUrl() {
                        try {
                            // Method 1: Look for the exact PDF link with openPDFNoticeWindow
                            var pdfLink = document.querySelector('a[onclick*=""openPDFNoticeWindow""]');
                            if (pdfLink) {
                                var onclick = pdfLink.getAttribute('onclick');
                                if (onclick) {
                                    var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                    if (match && match[1]) {
                                        var pdfUrl = match[1];
                                        if (pdfUrl.startsWith('/')) {
                                            pdfUrl = window.location.origin + pdfUrl;
                                        }
                                        return { success: true, url: pdfUrl, method: 'openPDFNoticeWindow' };
                                    }
                                }
                            }
                            
                            // Method 2: Look for any link with CP575 in href
                            var cp575Links = document.querySelectorAll('a[href*=""CP575""]');
                            for (var i = 0; i < cp575Links.length; i++) {
                                var href = cp575Links[i].href;
                                if (href && href.includes('CP575') && href.includes('.pdf')) {
                                    return { success: true, url: href, method: 'href_cp575' };
                                }
                            }
                            
                            // Method 3: Look for any link with .pdf extension
                            var pdfLinks = document.querySelectorAll('a[href*="".pdf""]');
                            for (var i = 0; i < pdfLinks.length; i++) {
                                var href = pdfLinks[i].href;
                                if (href && href.includes('.pdf')) {
                                    return { success: true, url: href, method: 'href_pdf' };
                                }
                            }
                            
                            // Method 4: Search in page source for PDF URLs
                            var pageText = document.documentElement.outerHTML;
                            var pdfUrlMatches = pageText.match(/\/modein\/notices\/CP575_[^""\s]+\.pdf/g);
                            if (pdfUrlMatches && pdfUrlMatches.length > 0) {
                                var pdfUrl = pdfUrlMatches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'page_source' };
                            }
                            
                            // Method 5: Look for any CP575 pattern in the page
                            var cp575Matches = pageText.match(/CP575_[^""\s]+\.pdf/g);
                            if (cp575Matches && cp575Matches.length > 0) {
                                var pdfUrl = '/modein/notices/' + cp575Matches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'cp575_pattern' };
                            }
                            
                            return { success: false, error: 'No PDF URL found' };
                        } catch (e) {
                            return { success: false, error: e.message };
                        }
                    }
                    return extractActualPdfUrl();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    if (jsResult.TryGetValue("success", out var success) && success is bool isSuccess && isSuccess)
                    {
                        if (jsResult.TryGetValue("url", out var url) && url is string pdfUrl)
                        {
                            var method = jsResult.TryGetValue("method", out var methodObj) ? methodObj?.ToString() : "unknown";
                            _logger.LogInformation("Successfully extracted actual PDF URL via {Method}: {Url}", method, pdfUrl);
                            return Task.FromResult<string?>(pdfUrl);
                        }
                    }
                    else if (jsResult.TryGetValue("error", out var error))
                    {
                        _logger.LogDebug("Failed to extract actual PDF URL: {Error}", error);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Actual PDF URL extraction failed: {Message}", ex.Message);
            }
            return Task.FromResult<string?>(null);
        }

        private async Task<byte[]?> TryCapturePdfFromBrowserViewer(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting comprehensive PDF capture from browser viewer");
                
                // Method 1: Check if we're already on a PDF page
                var currentUrl = Driver?.Url?.ToLower() ?? "";
                if (currentUrl.Contains(".pdf") || currentUrl.Contains("cp575"))
                {
                    _logger.LogInformation("Current page appears to be a PDF: {Url}", currentUrl);
                    
                    // Try all capture methods
                    var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully extracted PDF from current page: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryPrintToPdf(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully printed current page to PDF: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryCapturePdfFromPrintDialog(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully captured PDF from print dialog: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                }
                
                // Method 2: Search for PDF elements on the page
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                var script = @"
                    function findPdfElements() {
                        var pdfElements = [];
                        
                        // Look for PDF links
                        var links = document.querySelectorAll('a[href*="".pdf""], a[href*=""cp575""]');
                        for (var i = 0; i < links.length; i++) {
                            pdfElements.push({ type: 'link', href: links[i].href, text: links[i].textContent });
                        }
                        
                        // Look for PDF embeds
                        var embeds = document.querySelectorAll('embed[type=""application/pdf""]');
                        for (var i = 0; i < embeds.length; i++) {
                            pdfElements.push({ type: 'embed', src: embeds[i].src });
                        }
                        
                        // Look for PDF objects
                        var objects = document.querySelectorAll('object[type=""application/pdf""]');
                        for (var i = 0; i < objects.length; i++) {
                            pdfElements.push({ type: 'object', data: objects[i].data });
                        }
                        
                        // Look for iframes with PDFs
                        var iframes = document.querySelectorAll('iframe[src*="".pdf""]');
                        for (var i = 0; i < iframes.length; i++) {
                            pdfElements.push({ type: 'iframe', src: iframes[i].src });
                        }
                        
                        return pdfElements;
                    }
                    return findPdfElements();
                ";
                
                var pdfElements = jsExecutor?.ExecuteScript(script);
                if (pdfElements != null && pdfElements is IEnumerable<object> elements)
                {
                    foreach (var element in elements)
                    {
                        if (element is Dictionary<string, object> pdfElement)
                        {
                            var href = pdfElement.GetValueOrDefault("href")?.ToString();
                            var src = pdfElement.GetValueOrDefault("src")?.ToString();
                            var data = pdfElement.GetValueOrDefault("data")?.ToString();
                            
                            var url = href ?? src ?? data;
                            if (!string.IsNullOrEmpty(url))
                            {
                                _logger.LogInformation("Found PDF element: {Type}, URL: {Url}", 
                                    pdfElement.GetValueOrDefault("type"), url);
                                
                                var pdfBytes = await DownloadPdfFromUrl(url, cancellationToken);
                                if (pdfBytes != null && pdfBytes.Length > 0)
                                {
                                    _logger.LogInformation("Successfully downloaded PDF from element: {FileSize} bytes", pdfBytes.Length);
                                    return pdfBytes;
                                }
                            }
                        }
                    }
                }
                
                // Method 3: Try to trigger PDF download from any found elements
                var downloadSelectors = new[]
                {
                    "//a[contains(@href, '.pdf')]",
                    "//a[contains(@href, 'cp575')]",
                    "//button[contains(text(), 'Download')]",
                    "//button[contains(text(), 'View')]",
                    "//*[contains(text(), 'EIN Confirmation Letter')]",
                    "//*[contains(text(), 'confirmation letter')]"
                };
                
                foreach (var selector in downloadSelectors)
                {
                    try
                    {
                        var element = Driver?.FindElement(By.XPath(selector));
                        if (element != null && element.Displayed && element.Enabled)
                        {
                            _logger.LogInformation("Found PDF element with selector: {Selector}", selector);
                            
                            // Try clicking the element
                            element.Click();
                            await Task.Delay(3000, cancellationToken);
                            
                            // Check if a new window/tab opened
                            var newWindows = Driver?.WindowHandles.ToList();
                            var originalWindows = Driver?.WindowHandles.ToList();
                            
                            if (newWindows != null && newWindows.Count > originalWindows?.Count)
                            {
                                var newWindow = newWindows.FirstOrDefault(w => !originalWindows.Contains(w));
                                if (!string.IsNullOrEmpty(newWindow))
                                {
                                    Driver?.SwitchTo().Window(newWindow);
                                    await Task.Delay(2000, cancellationToken);
                                    
                                    var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                                    if (pdfBytes != null && pdfBytes.Length > 0)
                                    {
                                        _logger.LogInformation("Successfully captured PDF from new window: {FileSize} bytes", pdfBytes.Length);
                                        return pdfBytes;
                                    }
                                    
                                    // Close the new window and switch back
                                    Driver?.Close();
                                    Driver?.SwitchTo().Window(originalWindows.First());
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("PDF element selector {Selector} failed: {Message}", selector, ex.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Comprehensive PDF capture from browser viewer failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> DownloadPdfFromUrl(string? url, CancellationToken cancellationToken)
        {
            try
            {
                if (string.IsNullOrEmpty(url))
                {
                    return null;
                }

                _logger.LogInformation("Downloading PDF from URL: {Url}", url);

                // Get cookies from the current session
                var cookies = Driver?.Manage().Cookies.AllCookies;
                
                HttpClient httpClient;
                
                // Add cookies to HttpClient if available
                if (cookies != null && cookies.Count > 0)
                {
                    var cookieContainer = new CookieContainer();
                    foreach (var cookie in cookies)
                    {
                        try
                        {
                            cookieContainer.Add(new System.Net.Cookie(cookie.Name, cookie.Value, cookie.Path, cookie.Domain));
                        }
                        catch (Exception cookieEx)
                        {
                            _logger.LogDebug("Failed to add cookie {CookieName}: {Message}", cookie.Name, cookieEx.Message);
                        }
                    }
                    
                    var handler = new HttpClientHandler() { CookieContainer = cookieContainer };
                    httpClient = new HttpClient(handler);
                }
                else
                {
                    httpClient = new HttpClient();
                }
                
                using (httpClient)
                {
                    // Set appropriate headers
                    httpClient.DefaultRequestHeaders.Add("User-Agent", 
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
                    httpClient.DefaultRequestHeaders.Add("Accept", "application/pdf,*/*");
                    httpClient.DefaultRequestHeaders.Add("Referer", Driver?.Url);

                    httpClient.Timeout = TimeSpan.FromSeconds(30);
                    var response = await httpClient.GetAsync(url, cancellationToken);
                    
                    if (response.IsSuccessStatusCode)
                    {
                        var content = await response.Content.ReadAsByteArrayAsync(cancellationToken);
                        if (IsValidPdf(content))
                        {
                            _logger.LogInformation("PDF download successful: {FileSize} bytes", content.Length);
                            return content;
                        }
                        else
                        {
                            _logger.LogWarning("Download returned non-PDF content");
                        }
                    }
                    else
                    {
                        _logger.LogWarning("PDF download failed with status: {StatusCode}", response.StatusCode);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF download from URL failed: {Message}", ex.Message);
            }

            return null;
        }

        private async Task<byte[]?> TryDirectDownload(IWebElement pdfLinkElement, CancellationToken cancellationToken)
        {
            try
            {
                var href = pdfLinkElement.GetAttribute("href");
                if (string.IsNullOrEmpty(href))
                {
                    _logger.LogDebug("No href attribute found on PDF link");
                    return null;
                }

                _logger.LogInformation("Attempting direct download from URL: {Url}", href);

                // Get cookies from the current session
                var cookies = Driver?.Manage().Cookies.AllCookies;
                
                HttpClient httpClient;
                
                // Add cookies to HttpClient if available
                if (cookies != null && cookies.Count > 0)
                {
                    var cookieContainer = new CookieContainer();
                    foreach (var cookie in cookies)
                    {
                        try
                        {
                            cookieContainer.Add(new System.Net.Cookie(cookie.Name, cookie.Value, cookie.Path, cookie.Domain));
                        }
                        catch (Exception cookieEx)
                        {
                            _logger.LogDebug("Failed to add cookie {CookieName}: {Message}", cookie.Name, cookieEx.Message);
                        }
                    }
                }
                else
                {
                    httpClient = new HttpClient();
                }
                
                using (httpClient)
                {
                    // Set appropriate headers
                    httpClient.DefaultRequestHeaders.Add("User-Agent", 
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
                    httpClient.DefaultRequestHeaders.Add("Accept", "application/pdf,*/*");
                    httpClient.DefaultRequestHeaders.Add("Referer", Driver?.Url);

                    httpClient.Timeout = TimeSpan.FromSeconds(30);
                    var response = await httpClient.GetAsync(href, cancellationToken);
                    
                    if (response.IsSuccessStatusCode)
                    {
                        var content = await response.Content.ReadAsByteArrayAsync(cancellationToken);
                        if (IsValidPdf(content))
                        {
                            _logger.LogInformation("PDF download successful: {FileSize} bytes", content.Length);
                            return content;
                        }
                        else
                        {
                            _logger.LogWarning("Download returned non-PDF content");
                        }
                    }
                    else
                    {
                        _logger.LogWarning("PDF download failed with status: {StatusCode}", response.StatusCode);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF download from URL failed: {Message}", ex.Message);
            }

            return null;
        }

        private async Task<byte[]?> TryChromeDevToolsPdfCapture(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting Chrome DevTools PDF capture of current page");
                
                if (Driver is ChromeDriver chromeDriver)
                {
                    try
                    {
                        // Use the correct Chrome DevTools Protocol method
                        var printParams = new Dictionary<string, object>
                        {
                            ["landscape"] = false,
                            ["displayHeaderFooter"] = false,
                            ["printBackground"] = true,
                            ["preferCSSPageSize"] = true,
                            ["paperWidth"] = 8.27,
                            ["paperHeight"] = 11.69,
                            ["marginTop"] = 0.39,
                            ["marginBottom"] = 0.39,
                            ["marginLeft"] = 0.39,
                            ["marginRight"] = 0.39,
                            ["scale"] = 1.0
                        };
                        
                        var result = chromeDriver.ExecuteCdpCommand("Page.printToPDF", printParams);
                        
                        if (result is Dictionary<string, object> printResult &&
                            printResult.TryGetValue("data", out var base64Data))
                        {
                            var pdfBytes = Convert.FromBase64String(base64Data.ToString());
                            if (IsValidPdf(pdfBytes))
                            {
                                _logger.LogInformation("Successfully captured PDF via Chrome DevTools: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                            else
                            {
                                _logger.LogWarning("Chrome DevTools returned invalid PDF content");
                            }
                        }
                        else
                        {
                            _logger.LogWarning("Chrome DevTools PDF capture failed - no data returned");
                        }
                    }
                    catch (Exception cdpEx)
                    {
                        _logger.LogWarning("Chrome DevTools PDF capture failed: {Message}", cdpEx.Message);
                    }
                }
                else
                {
                    _logger.LogWarning("Driver is not ChromeDriver, cannot use DevTools Protocol");
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Chrome DevTools PDF capture failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryUltimateFallbackPdfDownload(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting ultimate fallback PDF download");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // Method 1: Extract all possible PDF URLs from the page
                var script = @"
                    function extractAllPdfUrls() {
                        var pdfUrls = [];
                        
                        // Extract from openPDFNoticeWindow functions
                        var openPdfLinks = document.querySelectorAll('a[onclick*=""openPDFNoticeWindow""]');
                        for (var i = 0; i < openPdfLinks.length; i++) {
                            var onclick = openPdfLinks[i].getAttribute('onclick');
                            if (onclick) {
                                var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                if (match && match[1]) {
                                    var url = match[1];
                                    if (url.startsWith('/')) {
                                        url = window.location.origin + url;
                                    }
                                    pdfUrls.push({ type: 'openPDFNoticeWindow', url: url });
                                }
                            }
                        }
                        
                        // Extract from href attributes with dynamic CP575 patterns
                        var hrefLinks = document.querySelectorAll('a[href*="".pdf""], a[href*=""CP575""]');
                        for (var i = 0; i < hrefLinks.length; i++) {
                            var href = hrefLinks[i].href;
                            if (href && (href.includes('.pdf') || href.includes('CP575'))) {
                                pdfUrls.push({ type: 'href', url: href });
                            }
                        }
                        
                        // Also look for any links containing CP575 in any format
                        var allLinks = document.querySelectorAll('a[href]');
                        for (var i = 0; i < allLinks.length; i++) {
                            var href = allLinks[i].href;
                            if (href && href.includes('CP575') && href.includes('.pdf')) {
                                pdfUrls.push({ type: 'cp575_dynamic', url: href });
                            }
                        }
                        
                        // Try to construct URL from page context
                        var currentUrl = window.location.href;
                        var baseUrl = window.location.origin;
                        
                        // Common PDF URL patterns with dynamic timestamps
                        var timestamp = Date.now();
                        var randomId = Math.random().toString(36).substring(2, 15);
                        var patterns = [
                            baseUrl + '/modein/notices/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + timestamp + '_' + randomId + '.pdf',
                            baseUrl + '/notices/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/CP575_' + timestamp + '.pdf',
                            baseUrl + '/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + randomId + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + timestamp + '_' + Date.now() + '.pdf'
                        ];
                        
                        return { pdfUrls: pdfUrls, patterns: patterns, baseUrl: baseUrl };
                    }
                    return extractAllPdfUrls();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    // Try each extracted URL
                    if (jsResult.TryGetValue("pdfUrls", out var pdfUrls) && pdfUrls is IEnumerable<object> urls)
                    {
                        foreach (var urlObj in urls)
                        {
                            if (urlObj is Dictionary<string, object> urlInfo)
                            {
                                if (urlInfo.TryGetValue("url", out var url) && url is string pdfUrl)
                                {
                                    _logger.LogInformation("Trying ultimate fallback URL: {Url}", pdfUrl);
                                    
                                    var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                                    if (pdfBytes != null && pdfBytes.Length > 0)
                                    {
                                        _logger.LogInformation("Ultimate fallback succeeded with URL: {Url}, Size: {FileSize} bytes", 
                                            pdfUrl, pdfBytes.Length);
                                        return pdfBytes;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Method 2: Try to construct URL from current page context
                    if (jsResult.TryGetValue("baseUrl", out var baseUrl) && baseUrl is string baseUrlStr)
                    {
                        var currentUrl = Driver?.Url ?? "";
                        var timestamp = DateTime.Now.Ticks;
                        
                        // Try different URL patterns with dynamic timestamps
                        var urlTimestamp = DateTime.Now.Ticks;
                        var randomId = Guid.NewGuid().ToString("N").Substring(0, 8);
                        var currentTime = DateTime.Now.Ticks;
                        
                        var urlPatterns = new[]
                        {
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}_{randomId}.pdf",
                            $"{baseUrlStr}/notices/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{randomId}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}_{currentTime}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{DateTimeOffset.Now.ToUnixTimeMilliseconds()}.pdf"
                        };
                        
                        foreach (var pattern in urlPatterns)
                        {
                            _logger.LogInformation("Trying constructed URL pattern: {Pattern}", pattern);
                            
                            var pdfBytes = await DownloadPdfFromUrl(pattern, cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Ultimate fallback succeeded with constructed URL: {Url}, Size: {FileSize} bytes", 
                                    pattern, pdfBytes.Length);
                                return pdfBytes;
                            }
                        }
                    }
                }
                
                // Method 3: Try to extract PDF URL from page source with dynamic patterns
                var pageSource = Driver?.PageSource ?? "";
                
                // Multiple regex patterns to catch different PDF URL formats
                var pdfUrlPatterns = new[]
                {
                    @"/modein/notices/CP575_\d+\.pdf",                    // Standard format
                    @"/modein/notices/CP575_\d+_\d+\.pdf",                // With additional timestamp
                    @"/modein/notices/CP575_[a-zA-Z0-9_]+\.pdf",          // Alphanumeric variations
                    @"/modein/notices/CP575_[a-zA-Z0-9_]+_[a-zA-Z0-9_]+\.pdf", // Multiple underscores
                    @"/notices/CP575_\d+\.pdf",                            // Without modein
                    @"/CP575_\d+\.pdf",                                    // Root level
                    @"/modein/CP575_\d+\.pdf",                             // Direct modein
                    @"/modein/notices/CP575_[^""\s]+\.pdf",                // Any characters except quotes/whitespace
                    @"/modein/notices/[^""\s]*CP575[^""\s]*\.pdf",         // CP575 anywhere in filename
                    @"/modein/notices/CP575_[a-zA-Z0-9_]{8,}\.pdf",       // At least 8 alphanumeric chars
                    @"/modein/notices/CP575_\d{10,}\.pdf",                 // At least 10 digits
                    @"/modein/notices/CP575_\d+[a-zA-Z0-9_]*\.pdf"        // Digits followed by optional chars
                };
                
                foreach (var pattern in pdfUrlPatterns)
                {
                    var pdfUrlMatches = Regex.Matches(pageSource, pattern);
                    
                    foreach (Match match in pdfUrlMatches)
                    {
                        var pdfUrl = match.Value;
                        if (pdfUrl.StartsWith("/"))
                        {
                            var baseUri = new Uri(Driver?.Url ?? "https://sa.www4.irs.gov");
                            pdfUrl = new Uri(baseUri, pdfUrl).ToString();
                        }
                        
                        _logger.LogInformation("Trying PDF URL from page source with pattern '{Pattern}': {Url}", pattern, pdfUrl);
                        
                        var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Ultimate fallback succeeded with page source URL: {Url}, Size: {FileSize} bytes", 
                                pdfUrl, pdfBytes.Length);
                            return pdfBytes;
                        }
                    }
                }
                
                // Method 4: Try to dynamically extract the actual PDF URL from the page
                _logger.LogInformation("Attempting to dynamically extract actual PDF URL from page");
                var dynamicPdfUrl = await TryExtractActualPdfUrlFromPage(cancellationToken);
                if (!string.IsNullOrEmpty(dynamicPdfUrl))
                {
                    _logger.LogInformation("Found actual PDF URL: {Url}", dynamicPdfUrl);
                    
                    var pdfBytes = await DownloadPdfFromUrl(dynamicPdfUrl, cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Ultimate fallback succeeded with actual PDF URL: {Url}, Size: {FileSize} bytes", 
                            dynamicPdfUrl, pdfBytes.Length);
                        return pdfBytes;
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Ultimate fallback PDF download failed: {Message}", ex.Message);
            }
            return null;
        }

        private Task<string?> TryExtractActualPdfUrlFromPage(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting to extract actual PDF URL from page");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // JavaScript to extract the actual PDF URL from the page
                var script = @"
                    function extractActualPdfUrl() {
                        try {
                            // Method 1: Look for the exact PDF link with openPDFNoticeWindow
                            var pdfLink = document.querySelector('a[onclick*=""openPDFNoticeWindow""]');
                            if (pdfLink) {
                                var onclick = pdfLink.getAttribute('onclick');
                                if (onclick) {
                                    var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                    if (match && match[1]) {
                                        var pdfUrl = match[1];
                                        if (pdfUrl.startsWith('/')) {
                                            pdfUrl = window.location.origin + pdfUrl;
                                        }
                                        return { success: true, url: pdfUrl, method: 'openPDFNoticeWindow' };
                                    }
                                }
                            }
                            
                            // Method 2: Look for any link with CP575 in href
                            var cp575Links = document.querySelectorAll('a[href*=""CP575""]');
                            for (var i = 0; i < cp575Links.length; i++) {
                                var href = cp575Links[i].href;
                                if (href && href.includes('CP575') && href.includes('.pdf')) {
                                    return { success: true, url: href, method: 'href_cp575' };
                                }
                            }
                            
                            // Method 3: Look for any link with .pdf extension
                            var pdfLinks = document.querySelectorAll('a[href*="".pdf""]');
                            for (var i = 0; i < pdfLinks.length; i++) {
                                var href = pdfLinks[i].href;
                                if (href && href.includes('.pdf')) {
                                    return { success: true, url: href, method: 'href_pdf' };
                                }
                            }
                            
                            // Method 4: Search in page source for PDF URLs
                            var pageText = document.documentElement.outerHTML;
                            var pdfUrlMatches = pageText.match(/\/modein\/notices\/CP575_[^""\s]+\.pdf/g);
                            if (pdfUrlMatches && pdfUrlMatches.length > 0) {
                                var pdfUrl = pdfUrlMatches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'page_source' };
                            }
                            
                            // Method 5: Look for any CP575 pattern in the page
                            var cp575Matches = pageText.match(/CP575_[^""\s]+\.pdf/g);
                            if (cp575Matches && cp575Matches.length > 0) {
                                var pdfUrl = '/modein/notices/' + cp575Matches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'cp575_pattern' };
                            }
                            
                            return { success: false, error: 'No PDF URL found' };
                        } catch (e) {
                            return { success: false, error: e.message };
                        }
                    }
                    return extractActualPdfUrl();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    if (jsResult.TryGetValue("success", out var success) && success is bool isSuccess && isSuccess)
                    {
                        if (jsResult.TryGetValue("url", out var url) && url is string pdfUrl)
                        {
                            var method = jsResult.TryGetValue("method", out var methodObj) ? methodObj?.ToString() : "unknown";
                            _logger.LogInformation("Successfully extracted actual PDF URL via {Method}: {Url}", method, pdfUrl);
                            return Task.FromResult<string?>(pdfUrl);
                        }
                    }
                    else if (jsResult.TryGetValue("error", out var error))
                    {
                        _logger.LogDebug("Failed to extract actual PDF URL: {Error}", error);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Actual PDF URL extraction failed: {Message}", ex.Message);
            }
            return Task.FromResult<string?>(null);
        }

        private async Task<byte[]?> TryCapturePdfFromBrowserViewer(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting comprehensive PDF capture from browser viewer");
                
                // Method 1: Check if we're already on a PDF page
                var currentUrl = Driver?.Url?.ToLower() ?? "";
                if (currentUrl.Contains(".pdf") || currentUrl.Contains("cp575"))
                {
                    _logger.LogInformation("Current page appears to be a PDF: {Url}", currentUrl);
                    
                    // Try all capture methods
                    var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully extracted PDF from current page: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryPrintToPdf(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully printed current page to PDF: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryCapturePdfFromPrintDialog(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully captured PDF from print dialog: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                }
                
                // Method 2: Search for PDF elements on the page
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                var script = @"
                    function findPdfElements() {
                        var pdfElements = [];
                        
                        // Look for PDF links
                        var links = document.querySelectorAll('a[href*="".pdf""], a[href*=""cp575""]');
                        for (var i = 0; i < links.length; i++) {
                            pdfElements.push({ type: 'link', href: links[i].href, text: links[i].textContent });
                        }
                        
                        // Look for PDF embeds
                        var embeds = document.querySelectorAll('embed[type=""application/pdf""]');
                        for (var i = 0; i < embeds.length; i++) {
                            pdfElements.push({ type: 'embed', src: embeds[i].src });
                        }
                        
                        // Look for PDF objects
                        var objects = document.querySelectorAll('object[type=""application/pdf""]');
                        for (var i = 0; i < objects.length; i++) {
                            pdfElements.push({ type: 'object', data: objects[i].data });
                        }
                        
                        // Look for iframes with PDFs
                        var iframes = document.querySelectorAll('iframe[src*="".pdf""]');
                        for (var i = 0; i < iframes.length; i++) {
                            pdfElements.push({ type: 'iframe', src: iframes[i].src });
                        }
                        
                        return pdfElements;
                    }
                    return findPdfElements();
                ";
                
                var pdfElements = jsExecutor?.ExecuteScript(script);
                if (pdfElements != null && pdfElements is IEnumerable<object> elements)
                {
                    foreach (var element in elements)
                    {
                        if (element is Dictionary<string, object> pdfElement)
                        {
                            var href = pdfElement.GetValueOrDefault("href")?.ToString();
                            var src = pdfElement.GetValueOrDefault("src")?.ToString();
                            var data = pdfElement.GetValueOrDefault("data")?.ToString();
                            
                            var url = href ?? src ?? data;
                            if (!string.IsNullOrEmpty(url))
                            {
                                _logger.LogInformation("Found PDF element: {Type}, URL: {Url}", 
                                    pdfElement.GetValueOrDefault("type"), url);
                                
                                var pdfBytes = await DownloadPdfFromUrl(url, cancellationToken);
                                if (pdfBytes != null && pdfBytes.Length > 0)
                                {
                                    _logger.LogInformation("Successfully downloaded PDF from element: {FileSize} bytes", pdfBytes.Length);
                                    return pdfBytes;
                                }
                            }
                        }
                    }
                }
                
                // Method 3: Try to trigger PDF download from any found elements
                var downloadSelectors = new[]
                {
                    "//a[contains(@href, '.pdf')]",
                    "//a[contains(@href, 'cp575')]",
                    "//button[contains(text(), 'Download')]",
                    "//button[contains(text(), 'View')]",
                    "//*[contains(text(), 'EIN Confirmation Letter')]",
                    "//*[contains(text(), 'confirmation letter')]"
                };
                
                foreach (var selector in downloadSelectors)
                {
                    try
                    {
                        var element = Driver?.FindElement(By.XPath(selector));
                        if (element != null && element.Displayed && element.Enabled)
                        {
                            _logger.LogInformation("Found PDF element with selector: {Selector}", selector);
                            
                            // Try clicking the element
                            element.Click();
                            await Task.Delay(3000, cancellationToken);
                            
                            // Check if a new window/tab opened
                            var newWindows = Driver?.WindowHandles.ToList();
                            var originalWindows = Driver?.WindowHandles.ToList();
                            
                            if (newWindows != null && newWindows.Count > originalWindows?.Count)
                            {
                                var newWindow = newWindows.FirstOrDefault(w => !originalWindows.Contains(w));
                                if (!string.IsNullOrEmpty(newWindow))
                                {
                                    Driver?.SwitchTo().Window(newWindow);
                                    await Task.Delay(2000, cancellationToken);
                                    
                                    var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                                    if (pdfBytes != null && pdfBytes.Length > 0)
                                    {
                                        _logger.LogInformation("Successfully captured PDF from new window: {FileSize} bytes", pdfBytes.Length);
                                        return pdfBytes;
                                    }
                                    
                                    // Close the new window and switch back
                                    Driver?.Close();
                                    Driver?.SwitchTo().Window(originalWindows.First());
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("PDF element selector {Selector} failed: {Message}", selector, ex.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Comprehensive PDF capture from browser viewer failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> DownloadPdfFromUrl(string? url, CancellationToken cancellationToken)
        {
            try
            {
                if (string.IsNullOrEmpty(url))
                {
                    return null;
                }

                _logger.LogInformation("Downloading PDF from URL: {Url}", url);

                // Get cookies from the current session
                var cookies = Driver?.Manage().Cookies.AllCookies;
                
                HttpClient httpClient;
                
                // Add cookies to HttpClient if available
                if (cookies != null && cookies.Count > 0)
                {
                    var cookieContainer = new CookieContainer();
                    foreach (var cookie in cookies)
                    {
                        try
                        {
                            cookieContainer.Add(new System.Net.Cookie(cookie.Name, cookie.Value, cookie.Path, cookie.Domain));
                        }
                        catch (Exception cookieEx)
                        {
                            _logger.LogDebug("Failed to add cookie {CookieName}: {Message}", cookie.Name, cookieEx.Message);
                        }
                    }
                    
                    var handler = new HttpClientHandler() { CookieContainer = cookieContainer };
                    httpClient = new HttpClient(handler);
                }
                else
                {
                    httpClient = new HttpClient();
                }
                
                using (httpClient)
                {
                    // Set appropriate headers
                    httpClient.DefaultRequestHeaders.Add("User-Agent", 
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
                    httpClient.DefaultRequestHeaders.Add("Accept", "application/pdf,*/*");
                    httpClient.DefaultRequestHeaders.Add("Referer", Driver?.Url);

                    httpClient.Timeout = TimeSpan.FromSeconds(30);
                    var response = await httpClient.GetAsync(url, cancellationToken);
                    
                    if (response.IsSuccessStatusCode)
                    {
                        var content = await response.Content.ReadAsByteArrayAsync(cancellationToken);
                        if (IsValidPdf(content))
                        {
                            _logger.LogInformation("PDF download successful: {FileSize} bytes", content.Length);
                            return content;
                        }
                        else
                        {
                            _logger.LogWarning("Download returned non-PDF content");
                        }
                    }
                    else
                    {
                        _logger.LogWarning("PDF download failed with status: {StatusCode}", response.StatusCode);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF download from URL failed: {Message}", ex.Message);
            }

            return null;
        }

        private async Task<byte[]?> TryDirectDownload(IWebElement pdfLinkElement, CancellationToken cancellationToken)
        {
            try
            {
                var href = pdfLinkElement.GetAttribute("href");
                if (string.IsNullOrEmpty(href))
                {
                    _logger.LogDebug("No href attribute found on PDF link");
                    return null;
                }

                _logger.LogInformation("Attempting direct download from URL: {Url}", href);

                // Get cookies from the current session
                var cookies = Driver?.Manage().Cookies.AllCookies;
                
                HttpClient httpClient;
                
                // Add cookies to HttpClient if available
                if (cookies != null && cookies.Count > 0)
                {
                    var cookieContainer = new CookieContainer();
                    foreach (var cookie in cookies)
                    {
                        try
                        {
                            cookieContainer.Add(new System.Net.Cookie(cookie.Name, cookie.Value, cookie.Path, cookie.Domain));
                        }
                        catch (Exception cookieEx)
                        {
                            _logger.LogDebug("Failed to add cookie {CookieName}: {Message}", cookie.Name, cookieEx.Message);
                        }
                    }
                }
                else
                {
                    httpClient = new HttpClient();
                }
                
                using (httpClient)
                {
                    // Set appropriate headers
                    httpClient.DefaultRequestHeaders.Add("User-Agent", 
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
                    httpClient.DefaultRequestHeaders.Add("Accept", "application/pdf,*/*");
                    httpClient.DefaultRequestHeaders.Add("Referer", Driver?.Url);

                    httpClient.Timeout = TimeSpan.FromSeconds(30);
                    var response = await httpClient.GetAsync(href, cancellationToken);
                    
                    if (response.IsSuccessStatusCode)
                    {
                        var content = await response.Content.ReadAsByteArrayAsync(cancellationToken);
                        if (IsValidPdf(content))
                        {
                            _logger.LogInformation("PDF download successful: {FileSize} bytes", content.Length);
                            return content;
                        }
                        else
                        {
                            _logger.LogWarning("Download returned non-PDF content");
                        }
                    }
                    else
                    {
                        _logger.LogWarning("PDF download failed with status: {StatusCode}", response.StatusCode);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF download from URL failed: {Message}", ex.Message);
            }

            return null;
        }

        private async Task<byte[]?> TryChromeDevToolsPdfCapture(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting Chrome DevTools PDF capture of current page");
                
                if (Driver is ChromeDriver chromeDriver)
                {
                    try
                    {
                        // Use the correct Chrome DevTools Protocol method
                        var printParams = new Dictionary<string, object>
                        {
                            ["landscape"] = false,
                            ["displayHeaderFooter"] = false,
                            ["printBackground"] = true,
                            ["preferCSSPageSize"] = true,
                            ["paperWidth"] = 8.27,
                            ["paperHeight"] = 11.69,
                            ["marginTop"] = 0.39,
                            ["marginBottom"] = 0.39,
                            ["marginLeft"] = 0.39,
                            ["marginRight"] = 0.39,
                            ["scale"] = 1.0
                        };
                        
                        var result = chromeDriver.ExecuteCdpCommand("Page.printToPDF", printParams);
                        
                        if (result is Dictionary<string, object> printResult &&
                            printResult.TryGetValue("data", out var base64Data))
                        {
                            var pdfBytes = Convert.FromBase64String(base64Data.ToString());
                            if (IsValidPdf(pdfBytes))
                            {
                                _logger.LogInformation("Successfully captured PDF via Chrome DevTools: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                            else
                            {
                                _logger.LogWarning("Chrome DevTools returned invalid PDF content");
                            }
                        }
                        else
                        {
                            _logger.LogWarning("Chrome DevTools PDF capture failed - no data returned");
                        }
                    }
                    catch (Exception cdpEx)
                    {
                        _logger.LogWarning("Chrome DevTools PDF capture failed: {Message}", cdpEx.Message);
                    }
                }
                else
                {
                    _logger.LogWarning("Driver is not ChromeDriver, cannot use DevTools Protocol");
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Chrome DevTools PDF capture failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryUltimateFallbackPdfDownload(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting ultimate fallback PDF download");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // Method 1: Extract all possible PDF URLs from the page
                var script = @"
                    function extractAllPdfUrls() {
                        var pdfUrls = [];
                        
                        // Extract from openPDFNoticeWindow functions
                        var openPdfLinks = document.querySelectorAll('a[onclick*=""openPDFNoticeWindow""]');
                        for (var i = 0; i < openPdfLinks.length; i++) {
                            var onclick = openPdfLinks[i].getAttribute('onclick');
                            if (onclick) {
                                var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                if (match && match[1]) {
                                    var url = match[1];
                                    if (url.startsWith('/')) {
                                        url = window.location.origin + url;
                                    }
                                    pdfUrls.push({ type: 'openPDFNoticeWindow', url: url });
                                }
                            }
                        }
                        
                        // Extract from href attributes with dynamic CP575 patterns
                        var hrefLinks = document.querySelectorAll('a[href*="".pdf""], a[href*=""CP575""]');
                        for (var i = 0; i < hrefLinks.length; i++) {
                            var href = hrefLinks[i].href;
                            if (href && (href.includes('.pdf') || href.includes('CP575'))) {
                                pdfUrls.push({ type: 'href', url: href });
                            }
                        }
                        
                        // Also look for any links containing CP575 in any format
                        var allLinks = document.querySelectorAll('a[href]');
                        for (var i = 0; i < allLinks.length; i++) {
                            var href = allLinks[i].href;
                            if (href && href.includes('CP575') && href.includes('.pdf')) {
                                pdfUrls.push({ type: 'cp575_dynamic', url: href });
                            }
                        }
                        
                        // Try to construct URL from page context
                        var currentUrl = window.location.href;
                        var baseUrl = window.location.origin;
                        
                        // Common PDF URL patterns with dynamic timestamps
                        var timestamp = Date.now();
                        var randomId = Math.random().toString(36).substring(2, 15);
                        var patterns = [
                            baseUrl + '/modein/notices/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + timestamp + '_' + randomId + '.pdf',
                            baseUrl + '/notices/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/CP575_' + timestamp + '.pdf',
                            baseUrl + '/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + randomId + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + timestamp + '_' + Date.now() + '.pdf'
                        ];
                        
                        return { pdfUrls: pdfUrls, patterns: patterns, baseUrl: baseUrl };
                    }
                    return extractAllPdfUrls();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    // Try each extracted URL
                    if (jsResult.TryGetValue("pdfUrls", out var pdfUrls) && pdfUrls is IEnumerable<object> urls)
                    {
                        foreach (var urlObj in urls)
                        {
                            if (urlObj is Dictionary<string, object> urlInfo)
                            {
                                if (urlInfo.TryGetValue("url", out var url) && url is string pdfUrl)
                                {
                                    _logger.LogInformation("Trying ultimate fallback URL: {Url}", pdfUrl);
                                    
                                    var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                                    if (pdfBytes != null && pdfBytes.Length > 0)
                                    {
                                        _logger.LogInformation("Ultimate fallback succeeded with URL: {Url}, Size: {FileSize} bytes", 
                                            pdfUrl, pdfBytes.Length);
                                        return pdfBytes;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Method 2: Try to construct URL from current page context
                    if (jsResult.TryGetValue("baseUrl", out var baseUrl) && baseUrl is string baseUrlStr)
                    {
                        var currentUrl = Driver?.Url ?? "";
                        var timestamp = DateTime.Now.Ticks;
                        
                        // Try different URL patterns with dynamic timestamps
                        var urlTimestamp = DateTime.Now.Ticks;
                        var randomId = Guid.NewGuid().ToString("N").Substring(0, 8);
                        var currentTime = DateTime.Now.Ticks;
                        
                        var urlPatterns = new[]
                        {
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}_{randomId}.pdf",
                            $"{baseUrlStr}/notices/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{randomId}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}_{currentTime}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{DateTimeOffset.Now.ToUnixTimeMilliseconds()}.pdf"
                        };
                        
                        foreach (var pattern in urlPatterns)
                        {
                            _logger.LogInformation("Trying constructed URL pattern: {Pattern}", pattern);
                            
                            var pdfBytes = await DownloadPdfFromUrl(pattern, cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Ultimate fallback succeeded with constructed URL: {Url}, Size: {FileSize} bytes", 
                                    pattern, pdfBytes.Length);
                                return pdfBytes;
                            }
                        }
                    }
                }
                
                // Method 3: Try to extract PDF URL from page source with dynamic patterns
                var pageSource = Driver?.PageSource ?? "";
                
                // Multiple regex patterns to catch different PDF URL formats
                var pdfUrlPatterns = new[]
                {
                    @"/modein/notices/CP575_\d+\.pdf",                    // Standard format
                    @"/modein/notices/CP575_\d+_\d+\.pdf",                // With additional timestamp
                    @"/modein/notices/CP575_[a-zA-Z0-9_]+\.pdf",          // Alphanumeric variations
                    @"/modein/notices/CP575_[a-zA-Z0-9_]+_[a-zA-Z0-9_]+\.pdf", // Multiple underscores
                    @"/notices/CP575_\d+\.pdf",                            // Without modein
                    @"/CP575_\d+\.pdf",                                    // Root level
                    @"/modein/CP575_\d+\.pdf",                             // Direct modein
                    @"/modein/notices/CP575_[^""\s]+\.pdf",                // Any characters except quotes/whitespace
                    @"/modein/notices/[^""\s]*CP575[^""\s]*\.pdf",         // CP575 anywhere in filename
                    @"/modein/notices/CP575_[a-zA-Z0-9_]{8,}\.pdf",       // At least 8 alphanumeric chars
                    @"/modein/notices/CP575_\d{10,}\.pdf",                 // At least 10 digits
                    @"/modein/notices/CP575_\d+[a-zA-Z0-9_]*\.pdf"        // Digits followed by optional chars
                };
                
                foreach (var pattern in pdfUrlPatterns)
                {
                    var pdfUrlMatches = Regex.Matches(pageSource, pattern);
                    
                    foreach (Match match in pdfUrlMatches)
                    {
                        var pdfUrl = match.Value;
                        if (pdfUrl.StartsWith("/"))
                        {
                            var baseUri = new Uri(Driver?.Url ?? "https://sa.www4.irs.gov");
                            pdfUrl = new Uri(baseUri, pdfUrl).ToString();
                        }
                        
                        _logger.LogInformation("Trying PDF URL from page source with pattern '{Pattern}': {Url}", pattern, pdfUrl);
                        
                        var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Ultimate fallback succeeded with page source URL: {Url}, Size: {FileSize} bytes", 
                                pdfUrl, pdfBytes.Length);
                            return pdfBytes;
                        }
                    }
                }
                
                // Method 4: Try to dynamically extract the actual PDF URL from the page
                _logger.LogInformation("Attempting to dynamically extract actual PDF URL from page");
                var dynamicPdfUrl = await TryExtractActualPdfUrlFromPage(cancellationToken);
                if (!string.IsNullOrEmpty(dynamicPdfUrl))
                {
                    _logger.LogInformation("Found actual PDF URL: {Url}", dynamicPdfUrl);
                    
                    var pdfBytes = await DownloadPdfFromUrl(dynamicPdfUrl, cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Ultimate fallback succeeded with actual PDF URL: {Url}, Size: {FileSize} bytes", 
                            dynamicPdfUrl, pdfBytes.Length);
                        return pdfBytes;
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Ultimate fallback PDF download failed: {Message}", ex.Message);
            }
            return null;
        }

        private Task<string?> TryExtractActualPdfUrlFromPage(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting to extract actual PDF URL from page");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // JavaScript to extract the actual PDF URL from the page
                var script = @"
                    function extractActualPdfUrl() {
                        try {
                            // Method 1: Look for the exact PDF link with openPDFNoticeWindow
                            var pdfLink = document.querySelector('a[onclick*=""openPDFNoticeWindow""]');
                            if (pdfLink) {
                                var onclick = pdfLink.getAttribute('onclick');
                                if (onclick) {
                                    var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                    if (match && match[1]) {
                                        var pdfUrl = match[1];
                                        if (pdfUrl.startsWith('/')) {
                                            pdfUrl = window.location.origin + pdfUrl;
                                        }
                                        return { success: true, url: pdfUrl, method: 'openPDFNoticeWindow' };
                                    }
                                }
                            }
                            
                            // Method 2: Look for any link with CP575 in href
                            var cp575Links = document.querySelectorAll('a[href*=""CP575""]');
                            for (var i = 0; i < cp575Links.length; i++) {
                                var href = cp575Links[i].href;
                                if (href && href.includes('CP575') && href.includes('.pdf')) {
                                    return { success: true, url: href, method: 'href_cp575' };
                                }
                            }
                            
                            // Method 3: Look for any link with .pdf extension
                            var pdfLinks = document.querySelectorAll('a[href*="".pdf""]');
                            for (var i = 0; i < pdfLinks.length; i++) {
                                var href = pdfLinks[i].href;
                                if (href && href.includes('.pdf')) {
                                    return { success: true, url: href, method: 'href_pdf' };
                                }
                            }
                            
                            // Method 4: Search in page source for PDF URLs
                            var pageText = document.documentElement.outerHTML;
                            var pdfUrlMatches = pageText.match(/\/modein\/notices\/CP575_[^""\s]+\.pdf/g);
                            if (pdfUrlMatches && pdfUrlMatches.length > 0) {
                                var pdfUrl = pdfUrlMatches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'page_source' };
                            }
                            
                            // Method 5: Look for any CP575 pattern in the page
                            var cp575Matches = pageText.match(/CP575_[^""\s]+\.pdf/g);
                            if (cp575Matches && cp575Matches.length > 0) {
                                var pdfUrl = '/modein/notices/' + cp575Matches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'cp575_pattern' };
                            }
                            
                            return { success: false, error: 'No PDF URL found' };
                        } catch (e) {
                            return { success: false, error: e.message };
                        }
                    }
                    return extractActualPdfUrl();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    if (jsResult.TryGetValue("success", out var success) && success is bool isSuccess && isSuccess)
                    {
                        if (jsResult.TryGetValue("url", out var url) && url is string pdfUrl)
                        {
                            var method = jsResult.TryGetValue("method", out var methodObj) ? methodObj?.ToString() : "unknown";
                            _logger.LogInformation("Successfully extracted actual PDF URL via {Method}: {Url}", method, pdfUrl);
                            return Task.FromResult<string?>(pdfUrl);
                        }
                    }
                    else if (jsResult.TryGetValue("error", out var error))
                    {
                        _logger.LogDebug("Failed to extract actual PDF URL: {Error}", error);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Actual PDF URL extraction failed: {Message}", ex.Message);
            }
            return Task.FromResult<string?>(null);
        }

        private async Task<byte[]?> TryCapturePdfFromBrowserViewer(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting comprehensive PDF capture from browser viewer");
                
                // Method 1: Check if we're already on a PDF page
                var currentUrl = Driver?.Url?.ToLower() ?? "";
                if (currentUrl.Contains(".pdf") || currentUrl.Contains("cp575"))
                {
                    _logger.LogInformation("Current page appears to be a PDF: {Url}", currentUrl);
                    
                    // Try all capture methods
                    var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully extracted PDF from current page: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryPrintToPdf(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully printed current page to PDF: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryCapturePdfFromPrintDialog(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully captured PDF from print dialog: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                }
                
                // Method 2: Search for PDF elements on the page
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                var script = @"
                    function findPdfElements() {
                        var pdfElements = [];
                        
                        // Look for PDF links
                        var links = document.querySelectorAll('a[href*="".pdf""], a[href*=""cp575""]');
                        for (var i = 0; i < links.length; i++) {
                            pdfElements.push({ type: 'link', href: links[i].href, text: links[i].textContent });
                        }
                        
                        // Look for PDF embeds
                        var embeds = document.querySelectorAll('embed[type=""application/pdf""]');
                        for (var i = 0; i < embeds.length; i++) {
                            pdfElements.push({ type: 'embed', src: embeds[i].src });
                        }
                        
                        // Look for PDF objects
                        var objects = document.querySelectorAll('object[type=""application/pdf""]');
                        for (var i = 0; i < objects.length; i++) {
                            pdfElements.push({ type: 'object', data: objects[i].data });
                        }
                        
                        // Look for iframes with PDFs
                        var iframes = document.querySelectorAll('iframe[src*="".pdf""]');
                        for (var i = 0; i < iframes.length; i++) {
                            pdfElements.push({ type: 'iframe', src: iframes[i].src });
                        }
                        
                        return pdfElements;
                    }
                    return findPdfElements();
                ";
                
                var pdfElements = jsExecutor?.ExecuteScript(script);
                if (pdfElements != null && pdfElements is IEnumerable<object> elements)
                {
                    foreach (var element in elements)
                    {
                        if (element is Dictionary<string, object> pdfElement)
                        {
                            var href = pdfElement.GetValueOrDefault("href")?.ToString();
                            var src = pdfElement.GetValueOrDefault("src")?.ToString();
                            var data = pdfElement.GetValueOrDefault("data")?.ToString();
                            
                            var url = href ?? src ?? data;
                            if (!string.IsNullOrEmpty(url))
                            {
                                _logger.LogInformation("Found PDF element: {Type}, URL: {Url}", 
                                    pdfElement.GetValueOrDefault("type"), url);
                                
                                var pdfBytes = await DownloadPdfFromUrl(url, cancellationToken);
                                if (pdfBytes != null && pdfBytes.Length > 0)
                                {
                                    _logger.LogInformation("Successfully downloaded PDF from element: {FileSize} bytes", pdfBytes.Length);
                                    return pdfBytes;
                                }
                            }
                        }
                    }
                }
                
                // Method 3: Try to trigger PDF download from any found elements
                var downloadSelectors = new[]
                {
                    "//a[contains(@href, '.pdf')]",
                    "//a[contains(@href, 'cp575')]",
                    "//button[contains(text(), 'Download')]",
                    "//button[contains(text(), 'View')]",
                    "//*[contains(text(), 'EIN Confirmation Letter')]",
                    "//*[contains(text(), 'confirmation letter')]"
                };
                
                foreach (var selector in downloadSelectors)
                {
                    try
                    {
                        var element = Driver?.FindElement(By.XPath(selector));
                        if (element != null && element.Displayed && element.Enabled)
                        {
                            _logger.LogInformation("Found PDF element with selector: {Selector}", selector);
                            
                            // Try clicking the element
                            element.Click();
                            await Task.Delay(3000, cancellationToken);
                            
                            // Check if a new window/tab opened
                            var newWindows = Driver?.WindowHandles.ToList();
                            var originalWindows = Driver?.WindowHandles.ToList();
                            
                            if (newWindows != null && newWindows.Count > originalWindows?.Count)
                            {
                                var newWindow = newWindows.FirstOrDefault(w => !originalWindows.Contains(w));
                                if (!string.IsNullOrEmpty(newWindow))
                                {
                                    Driver?.SwitchTo().Window(newWindow);
                                    await Task.Delay(2000, cancellationToken);
                                    
                                    var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                                    if (pdfBytes != null && pdfBytes.Length > 0)
                                    {
                                        _logger.LogInformation("Successfully captured PDF from new window: {FileSize} bytes", pdfBytes.Length);
                                        return pdfBytes;
                                    }
                                    
                                    // Close the new window and switch back
                                    Driver?.Close();
                                    Driver?.SwitchTo().Window(originalWindows.First());
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug("PDF element selector {Selector} failed: {Message}", selector, ex.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Comprehensive PDF capture from browser viewer failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> DownloadPdfFromUrl(string? url, CancellationToken cancellationToken)
        {
            try
            {
                if (string.IsNullOrEmpty(url))
                {
                    return null;
                }

                _logger.LogInformation("Downloading PDF from URL: {Url}", url);

                // Get cookies from the current session
                var cookies = Driver?.Manage().Cookies.AllCookies;
                
                HttpClient httpClient;
                
                // Add cookies to HttpClient if available
                if (cookies != null && cookies.Count > 0)
                {
                    var cookieContainer = new CookieContainer();
                    foreach (var cookie in cookies)
                    {
                        try
                        {
                            cookieContainer.Add(new System.Net.Cookie(cookie.Name, cookie.Value, cookie.Path, cookie.Domain));
                        }
                        catch (Exception cookieEx)
                        {
                            _logger.LogDebug("Failed to add cookie {CookieName}: {Message}", cookie.Name, cookieEx.Message);
                        }
                    }
                    
                    var handler = new HttpClientHandler() { CookieContainer = cookieContainer };
                    httpClient = new HttpClient(handler);
                }
                else
                {
                    httpClient = new HttpClient();
                }
                
                using (httpClient)
                {
                    // Set appropriate headers
                    httpClient.DefaultRequestHeaders.Add("User-Agent", 
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
                    httpClient.DefaultRequestHeaders.Add("Accept", "application/pdf,*/*");
                    httpClient.DefaultRequestHeaders.Add("Referer", Driver?.Url);

                    httpClient.Timeout = TimeSpan.FromSeconds(30);
                    var response = await httpClient.GetAsync(url, cancellationToken);
                    
                    if (response.IsSuccessStatusCode)
                    {
                        var content = await response.Content.ReadAsByteArrayAsync(cancellationToken);
                        if (IsValidPdf(content))
                        {
                            _logger.LogInformation("PDF download successful: {FileSize} bytes", content.Length);
                            return content;
                        }
                        else
                        {
                            _logger.LogWarning("Download returned non-PDF content");
                        }
                    }
                    else
                    {
                        _logger.LogWarning("PDF download failed with status: {StatusCode}", response.StatusCode);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF download from URL failed: {Message}", ex.Message);
            }

            return null;
        }

        private async Task<byte[]?> TryDirectDownload(IWebElement pdfLinkElement, CancellationToken cancellationToken)
        {
            try
            {
                var href = pdfLinkElement.GetAttribute("href");
                if (string.IsNullOrEmpty(href))
                {
                    _logger.LogDebug("No href attribute found on PDF link");
                    return null;
                }

                _logger.LogInformation("Attempting direct download from URL: {Url}", href);

                // Get cookies from the current session
                var cookies = Driver?.Manage().Cookies.AllCookies;
                
                HttpClient httpClient;
                
                // Add cookies to HttpClient if available
                if (cookies != null && cookies.Count > 0)
                {
                    var cookieContainer = new CookieContainer();
                    foreach (var cookie in cookies)
                    {
                        try
                        {
                            cookieContainer.Add(new System.Net.Cookie(cookie.Name, cookie.Value, cookie.Path, cookie.Domain));
                        }
                        catch (Exception cookieEx)
                        {
                            _logger.LogDebug("Failed to add cookie {CookieName}: {Message}", cookie.Name, cookieEx.Message);
                        }
                    }
                }
                else
                {
                    httpClient = new HttpClient();
                }
                
                using (httpClient)
                {
                    // Set appropriate headers
                    httpClient.DefaultRequestHeaders.Add("User-Agent", 
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
                    httpClient.DefaultRequestHeaders.Add("Accept", "application/pdf,*/*");
                    httpClient.DefaultRequestHeaders.Add("Referer", Driver?.Url);

                    httpClient.Timeout = TimeSpan.FromSeconds(30);
                    var response = await httpClient.GetAsync(href, cancellationToken);
                    
                    if (response.IsSuccessStatusCode)
                    {
                        var content = await response.Content.ReadAsByteArrayAsync(cancellationToken);
                        if (IsValidPdf(content))
                        {
                            _logger.LogInformation("PDF download successful: {FileSize} bytes", content.Length);
                            return content;
                        }
                        else
                        {
                            _logger.LogWarning("Download returned non-PDF content");
                        }
                    }
                    else
                    {
                        _logger.LogWarning("PDF download failed with status: {StatusCode}", response.StatusCode);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("PDF download from URL failed: {Message}", ex.Message);
            }

            return null;
        }

        private async Task<byte[]?> TryChromeDevToolsPdfCapture(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting Chrome DevTools PDF capture of current page");
                
                if (Driver is ChromeDriver chromeDriver)
                {
                    try
                    {
                        // Use the correct Chrome DevTools Protocol method
                        var printParams = new Dictionary<string, object>
                        {
                            ["landscape"] = false,
                            ["displayHeaderFooter"] = false,
                            ["printBackground"] = true,
                            ["preferCSSPageSize"] = true,
                            ["paperWidth"] = 8.27,
                            ["paperHeight"] = 11.69,
                            ["marginTop"] = 0.39,
                            ["marginBottom"] = 0.39,
                            ["marginLeft"] = 0.39,
                            ["marginRight"] = 0.39,
                            ["scale"] = 1.0
                        };
                        
                        var result = chromeDriver.ExecuteCdpCommand("Page.printToPDF", printParams);
                        
                        if (result is Dictionary<string, object> printResult &&
                            printResult.TryGetValue("data", out var base64Data))
                        {
                            var pdfBytes = Convert.FromBase64String(base64Data.ToString());
                            if (IsValidPdf(pdfBytes))
                            {
                                _logger.LogInformation("Successfully captured PDF via Chrome DevTools: {FileSize} bytes", pdfBytes.Length);
                                return pdfBytes;
                            }
                            else
                            {
                                _logger.LogWarning("Chrome DevTools returned invalid PDF content");
                            }
                        }
                        else
                        {
                            _logger.LogWarning("Chrome DevTools PDF capture failed - no data returned");
                        }
                    }
                    catch (Exception cdpEx)
                    {
                        _logger.LogWarning("Chrome DevTools PDF capture failed: {Message}", cdpEx.Message);
                    }
                }
                else
                {
                    _logger.LogWarning("Driver is not ChromeDriver, cannot use DevTools Protocol");
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Chrome DevTools PDF capture failed: {Message}", ex.Message);
            }
            return null;
        }

        private async Task<byte[]?> TryUltimateFallbackPdfDownload(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting ultimate fallback PDF download");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // Method 1: Extract all possible PDF URLs from the page
                var script = @"
                    function extractAllPdfUrls() {
                        var pdfUrls = [];
                        
                        // Extract from openPDFNoticeWindow functions
                        var openPdfLinks = document.querySelectorAll('a[onclick*=""openPDFNoticeWindow""]');
                        for (var i = 0; i < openPdfLinks.length; i++) {
                            var onclick = openPdfLinks[i].getAttribute('onclick');
                            if (onclick) {
                                var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                if (match && match[1]) {
                                    var url = match[1];
                                    if (url.startsWith('/')) {
                                        url = window.location.origin + url;
                                    }
                                    pdfUrls.push({ type: 'openPDFNoticeWindow', url: url });
                                }
                            }
                        }
                        
                        // Extract from href attributes with dynamic CP575 patterns
                        var hrefLinks = document.querySelectorAll('a[href*="".pdf""], a[href*=""CP575""]');
                        for (var i = 0; i < hrefLinks.length; i++) {
                            var href = hrefLinks[i].href;
                            if (href && (href.includes('.pdf') || href.includes('CP575'))) {
                                pdfUrls.push({ type: 'href', url: href });
                            }
                        }
                        
                        // Also look for any links containing CP575 in any format
                        var allLinks = document.querySelectorAll('a[href]');
                        for (var i = 0; i < allLinks.length; i++) {
                            var href = allLinks[i].href;
                            if (href && href.includes('CP575') && href.includes('.pdf')) {
                                pdfUrls.push({ type: 'cp575_dynamic', url: href });
                            }
                        }
                        
                        // Try to construct URL from page context
                        var currentUrl = window.location.href;
                        var baseUrl = window.location.origin;
                        
                        // Common PDF URL patterns with dynamic timestamps
                        var timestamp = Date.now();
                        var randomId = Math.random().toString(36).substring(2, 15);
                        var patterns = [
                            baseUrl + '/modein/notices/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + timestamp + '_' + randomId + '.pdf',
                            baseUrl + '/notices/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/CP575_' + timestamp + '.pdf',
                            baseUrl + '/CP575_' + timestamp + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + randomId + '.pdf',
                            baseUrl + '/modein/notices/CP575_' + timestamp + '_' + Date.now() + '.pdf'
                        ];
                        
                        return { pdfUrls: pdfUrls, patterns: patterns, baseUrl: baseUrl };
                    }
                    return extractAllPdfUrls();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    // Try each extracted URL
                    if (jsResult.TryGetValue("pdfUrls", out var pdfUrls) && pdfUrls is IEnumerable<object> urls)
                    {
                        foreach (var urlObj in urls)
                        {
                            if (urlObj is Dictionary<string, object> urlInfo)
                            {
                                if (urlInfo.TryGetValue("url", out var url) && url is string pdfUrl)
                                {
                                    _logger.LogInformation("Trying ultimate fallback URL: {Url}", pdfUrl);
                                    
                                    var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                                    if (pdfBytes != null && pdfBytes.Length > 0)
                                    {
                                        _logger.LogInformation("Ultimate fallback succeeded with URL: {Url}, Size: {FileSize} bytes", 
                                            pdfUrl, pdfBytes.Length);
                                        return pdfBytes;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Method 2: Try to construct URL from current page context
                    if (jsResult.TryGetValue("baseUrl", out var baseUrl) && baseUrl is string baseUrlStr)
                    {
                        var currentUrl = Driver?.Url ?? "";
                        var timestamp = DateTime.Now.Ticks;
                        
                        // Try different URL patterns with dynamic timestamps
                        var urlTimestamp = DateTime.Now.Ticks;
                        var randomId = Guid.NewGuid().ToString("N").Substring(0, 8);
                        var currentTime = DateTime.Now.Ticks;
                        
                        var urlPatterns = new[]
                        {
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}_{randomId}.pdf",
                            $"{baseUrlStr}/notices/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/CP575_{urlTimestamp}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{randomId}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{urlTimestamp}_{currentTime}.pdf",
                            $"{baseUrlStr}/modein/notices/CP575_{DateTimeOffset.Now.ToUnixTimeMilliseconds()}.pdf"
                        };
                        
                        foreach (var pattern in urlPatterns)
                        {
                            _logger.LogInformation("Trying constructed URL pattern: {Pattern}", pattern);
                            
                            var pdfBytes = await DownloadPdfFromUrl(pattern, cancellationToken);
                            if (pdfBytes != null && pdfBytes.Length > 0)
                            {
                                _logger.LogInformation("Ultimate fallback succeeded with constructed URL: {Url}, Size: {FileSize} bytes", 
                                    pattern, pdfBytes.Length);
                                return pdfBytes;
                            }
                        }
                    }
                }
                
                // Method 3: Try to extract PDF URL from page source with dynamic patterns
                var pageSource = Driver?.PageSource ?? "";
                
                // Multiple regex patterns to catch different PDF URL formats
                var pdfUrlPatterns = new[]
                {
                    @"/modein/notices/CP575_\d+\.pdf",                    // Standard format
                    @"/modein/notices/CP575_\d+_\d+\.pdf",                // With additional timestamp
                    @"/modein/notices/CP575_[a-zA-Z0-9_]+\.pdf",          // Alphanumeric variations
                    @"/modein/notices/CP575_[a-zA-Z0-9_]+_[a-zA-Z0-9_]+\.pdf", // Multiple underscores
                    @"/notices/CP575_\d+\.pdf",                            // Without modein
                    @"/CP575_\d+\.pdf",                                    // Root level
                    @"/modein/CP575_\d+\.pdf",                             // Direct modein
                    @"/modein/notices/CP575_[^""\s]+\.pdf",                // Any characters except quotes/whitespace
                    @"/modein/notices/[^""\s]*CP575[^""\s]*\.pdf",         // CP575 anywhere in filename
                    @"/modein/notices/CP575_[a-zA-Z0-9_]{8,}\.pdf",       // At least 8 alphanumeric chars
                    @"/modein/notices/CP575_\d{10,}\.pdf",                 // At least 10 digits
                    @"/modein/notices/CP575_\d+[a-zA-Z0-9_]*\.pdf"        // Digits followed by optional chars
                };
                
                foreach (var pattern in pdfUrlPatterns)
                {
                    var pdfUrlMatches = Regex.Matches(pageSource, pattern);
                    
                    foreach (Match match in pdfUrlMatches)
                    {
                        var pdfUrl = match.Value;
                        if (pdfUrl.StartsWith("/"))
                        {
                            var baseUri = new Uri(Driver?.Url ?? "https://sa.www4.irs.gov");
                            pdfUrl = new Uri(baseUri, pdfUrl).ToString();
                        }
                        
                        _logger.LogInformation("Trying PDF URL from page source with pattern '{Pattern}': {Url}", pattern, pdfUrl);
                        
                        var pdfBytes = await DownloadPdfFromUrl(pdfUrl, cancellationToken);
                        if (pdfBytes != null && pdfBytes.Length > 0)
                        {
                            _logger.LogInformation("Ultimate fallback succeeded with page source URL: {Url}, Size: {FileSize} bytes", 
                                pdfUrl, pdfBytes.Length);
                            return pdfBytes;
                        }
                    }
                }
                
                // Method 4: Try to dynamically extract the actual PDF URL from the page
                _logger.LogInformation("Attempting to dynamically extract actual PDF URL from page");
                var dynamicPdfUrl = await TryExtractActualPdfUrlFromPage(cancellationToken);
                if (!string.IsNullOrEmpty(dynamicPdfUrl))
                {
                    _logger.LogInformation("Found actual PDF URL: {Url}", dynamicPdfUrl);
                    
                    var pdfBytes = await DownloadPdfFromUrl(dynamicPdfUrl, cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Ultimate fallback succeeded with actual PDF URL: {Url}, Size: {FileSize} bytes", 
                            dynamicPdfUrl, pdfBytes.Length);
                        return pdfBytes;
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Ultimate fallback PDF download failed: {Message}", ex.Message);
            }
            return null;
        }

        private Task<string?> TryExtractActualPdfUrlFromPage(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting to extract actual PDF URL from page");
                
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                
                // JavaScript to extract the actual PDF URL from the page
                var script = @"
                    function extractActualPdfUrl() {
                        try {
                            // Method 1: Look for the exact PDF link with openPDFNoticeWindow
                            var pdfLink = document.querySelector('a[onclick*=""openPDFNoticeWindow""]');
                            if (pdfLink) {
                                var onclick = pdfLink.getAttribute('onclick');
                                if (onclick) {
                                    var match = onclick.match(/openPDFNoticeWindow\('([^']+)'\)/);
                                    if (match && match[1]) {
                                        var pdfUrl = match[1];
                                        if (pdfUrl.startsWith('/')) {
                                            pdfUrl = window.location.origin + pdfUrl;
                                        }
                                        return { success: true, url: pdfUrl, method: 'openPDFNoticeWindow' };
                                    }
                                }
                            }
                            
                            // Method 2: Look for any link with CP575 in href
                            var cp575Links = document.querySelectorAll('a[href*=""CP575""]');
                            for (var i = 0; i < cp575Links.length; i++) {
                                var href = cp575Links[i].href;
                                if (href && href.includes('CP575') && href.includes('.pdf')) {
                                    return { success: true, url: href, method: 'href_cp575' };
                                }
                            }
                            
                            // Method 3: Look for any link with .pdf extension
                            var pdfLinks = document.querySelectorAll('a[href*="".pdf""]');
                            for (var i = 0; i < pdfLinks.length; i++) {
                                var href = pdfLinks[i].href;
                                if (href && href.includes('.pdf')) {
                                    return { success: true, url: href, method: 'href_pdf' };
                                }
                            }
                            
                            // Method 4: Search in page source for PDF URLs
                            var pageText = document.documentElement.outerHTML;
                            var pdfUrlMatches = pageText.match(/\/modein\/notices\/CP575_[^""\s]+\.pdf/g);
                            if (pdfUrlMatches && pdfUrlMatches.length > 0) {
                                var pdfUrl = pdfUrlMatches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'page_source' };
                            }
                            
                            // Method 5: Look for any CP575 pattern in the page
                            var cp575Matches = pageText.match(/CP575_[^""\s]+\.pdf/g);
                            if (cp575Matches && cp575Matches.length > 0) {
                                var pdfUrl = '/modein/notices/' + cp575Matches[0];
                                if (pdfUrl.startsWith('/')) {
                                    pdfUrl = window.location.origin + pdfUrl;
                                }
                                return { success: true, url: pdfUrl, method: 'cp575_pattern' };
                            }
                            
                            return { success: false, error: 'No PDF URL found' };
                        } catch (e) {
                            return { success: false, error: e.message };
                        }
                    }
                    return extractActualPdfUrl();
                ";
                
                var result = jsExecutor?.ExecuteScript(script);
                if (result != null && result is Dictionary<string, object> jsResult)
                {
                    if (jsResult.TryGetValue("success", out var success) && success is bool isSuccess && isSuccess)
                    {
                        if (jsResult.TryGetValue("url", out var url) && url is string pdfUrl)
                        {
                            var method = jsResult.TryGetValue("method", out var methodObj) ? methodObj?.ToString() : "unknown";
                            _logger.LogInformation("Successfully extracted actual PDF URL via {Method}: {Url}", method, pdfUrl);
                            return Task.FromResult<string?>(pdfUrl);
                        }
                    }
                    else if (jsResult.TryGetValue("error", out var error))
                    {
                        _logger.LogDebug("Failed to extract actual PDF URL: {Error}", error);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug("Actual PDF URL extraction failed: {Message}", ex.Message);
            }
            return Task.FromResult<string?>(null);
        }

        private async Task<byte[]?> TryCapturePdfFromBrowserViewer(CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Attempting comprehensive PDF capture from browser viewer");
                
                // Method 1: Check if we're already on a PDF page
                var currentUrl = Driver?.Url?.ToLower() ?? "";
                if (currentUrl.Contains(".pdf") || currentUrl.Contains("cp575"))
                {
                    _logger.LogInformation("Current page appears to be a PDF: {Url}", currentUrl);
                    
                    // Try all capture methods
                    var pdfBytes = await TryExtractPdfContentFromViewer(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully extracted PDF from current page: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryPrintToPdf(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully printed current page to PDF: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                    
                    pdfBytes = await TryCapturePdfFromPrintDialog(cancellationToken);
                    if (pdfBytes != null && pdfBytes.Length > 0)
                    {
                        _logger.LogInformation("Successfully captured PDF from print dialog: {FileSize} bytes", pdfBytes.Length);
                        return pdfBytes;
                    }
                }
                
                // Method 2: Search for PDF elements on the page
                var jsExecutor = (IJavaScriptExecutor?)Driver;
                var script = @"
                    function findPdfElements() {
                        var pdfElements = [];
                        
                        // Look for PDF links
                        var links = document.querySelectorAll('a[href*="".pdf""], a[href*=""cp575""]');
                        for (var i = 0; i < links.length; i++) {
                            pdfElements.push({ type: 'link', href: links[i].href, text: links[i].textContent });
                        }
                        
                        // Look for PDF embeds
                        var embeds = document.querySelectorAll('embed[type=""application/pdf""]');
                        for (var i = 0; i < embeds.length; i++) {
                            pdfElements.push({ type: 'embed', src: embeds[i].src });
                        }
                        
                        // Look for PDF objects
                        var objects = document.querySelectorAll('object[type=""application/pdf""]');
                        for (var i = 0; i < objects.length; i++) {
                            pdfElements.push({ type: 'object', data: objects[i].data });
                        }
                        
                        // Look for iframes with PDFs
                        var iframes = document.querySelectorAll('iframe[src*="".pdf""]');
                        for (var i = 0; i < iframes.length; i++) {
                            pdfElements.push({ type: 'iframe', src: iframes[i].src });
                        }
                        
                        return pdfElements;
                    }
                    return findPdfElements();
                ";
                
                var pdfElements = jsExecutor?.ExecuteScript(script);
                if (pdfElements != null && pdfElements is IEnumerable<object> elements)
                {
                    foreach (var element in elements)
                    {
                        if (element is Dictionary<string, object> pdfElement)
                        {
                            var href = pdfElement.GetValueOrDefault("href")?.ToString();
                            var src = pdfElement.GetValueOrDefault("